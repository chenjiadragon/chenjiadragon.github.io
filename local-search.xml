<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>(roscpp) Callbacks and Spinning</title>
    <link href="/2022/10/27/roscpp-Callbacks-and-Spinning/"/>
    <url>/2022/10/27/roscpp-Callbacks-and-Spinning/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单线程Spinning"><a href="#1-单线程Spinning" class="headerlink" title="1. 单线程Spinning"></a>1. 单线程Spinning</h1><p>刚学习ROS，在程序中会看到两个语句：ros::spin()和ros::spinOnce()。这两函数的学名叫<strong>ROS消息回调处理函数</strong>，他俩通常会出现在ROS主循环中，当你的ROS结点只有一个单线程（一个单线程可以有多个回调函数）时，一般都会用到这两函数其中一个。ros::spin()和ros::spinOnec()的具体使用区别如下：</p><h2 id="ros-spin"><a href="#ros-spin" class="headerlink" title="ros::spin()"></a>ros::spin()</h2><p>ros::spin()的作用是：程序在运行到ros::spin()时，所有的用户回调函数都将在ros::spin()调用中调用，并且是循环调用。ros::spin()将不会返回，直到调用ros::shutdown()或Ctrl-C关闭结点停止运行。</p><p><strong>发送端：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);<br>    ros::NodeHandle n;<br>    <span class="hljs-comment">//1000 为queue_size大小，设置为１：实时性，只保留最新的。０：表示为无穷大。</span><br>    <span class="hljs-comment">//关于queue_size的详解：https://blog.csdn.net/handsome_for_kill/article/details/81984428</span><br>    ros::Publisher chatter_pub = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br> <br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>    &#123;<br>        std_msgs::String msg;<br>        std::stringstream ss;<br>        ss &lt;&lt; <span class="hljs-string">&quot;hello world &quot;</span> &lt;&lt; count;<br>        msg.data = ss.<span class="hljs-built_in">str</span>();<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg.data.<span class="hljs-built_in">c_str</span>());<br>        <br>        <span class="hljs-comment">// 向 Topic: chatter 发送消息, 发送频率为10Hz（1秒发10次）；消息池最大容量1000。</span><br>        chatter_pub.<span class="hljs-built_in">publish</span>(msg);<br>        loop_rate.<span class="hljs-built_in">sleep</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>订阅端：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br>    ros::NodeHandle n;<br>    ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, chatterCallback);<span class="hljs-comment">//1000为回调函数的队列长度</span><br>    ros::<span class="hljs-built_in">spin</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ros-spinOnce"><a href="#ros-spinOnce" class="headerlink" title="ros::spinOnce()"></a>ros::spinOnce()</h2><p>顾名思义，ros::spinOnce()则是只阻塞一次，等待所有回调函数运行一次之后，程序将继续向下进行。我们将可以根据自己的需求设置接受频率，可以看出，ros::spinOnce()更加主动灵活。</p><p>消息的发送和上面一样，消息的订阅如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*...TODO...*/</span> <br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br>    ros::NodeHandle n;<br>    ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">2</span>, chatterCallback);<br>  <br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;　<span class="hljs-comment">//频率为５hz</span><br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>    &#123;<br>        <span class="hljs-comment">/*...TODO...*/</span> <br>        ros::<span class="hljs-built_in">spinOnce</span>();<br>        loop_rate.<span class="hljs-built_in">sleep</span>(); <span class="hljs-comment">//配合执行频率，sleep一段时间，然后进入下一个循环。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-多线程Spinning"><a href="#2-多线程Spinning" class="headerlink" title="2. 多线程Spinning"></a>2. 多线程Spinning</h1><h2 id="使用多线程的必要性"><a href="#使用多线程的必要性" class="headerlink" title="使用多线程的必要性"></a>使用多线程的必要性</h2><p>对于一些只订阅一个话题的简单节点来说，我们使用ros::spin()或ros::spinOnce()进入接收循环，每当有订阅的话题发布时，进入回调函数接收和处理消息数据。但是更多的时候，一个节点往往要接收和处理不同来源的数据，并且这些数据的产生频率也各不相同，当我们在一个回调函数里耗费太多时间时，会导致其他回调函数被阻塞，导致数据丢失。下面是一个<a href="https://github.com/wenglihong/wlh_ros_demo/blob/master/multi_thread_demo/src/multi_topic_pub.cpp">发送端</a>和<a href="https://github.com/wenglihong/wlh_ros_demo/blob/master/multi_thread_demo/src/multi_topic_sub.cpp">订阅端</a>的例子：</p><p><strong>发送端</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><br>ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;multi_pub&quot;</span>);<br><br><br>ros::NodeHandle n;<br><br><br>ros::Publisher chatter_pub = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="hljs-string">&quot;chatter1&quot;</span>, <span class="hljs-number">1</span>);<br>ros::Publisher pub2 = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="hljs-string">&quot;chatter2&quot;</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br><br>std_msgs::String msg;<br>std::stringstream ss;<br>ss &lt;&lt; <span class="hljs-string">&quot;hello world &quot;</span> &lt;&lt; count;<br>msg.data = ss.<span class="hljs-built_in">str</span>();<br><br>std_msgs::String msg2;<br>std::stringstream ss2;<br>ss2 &lt;&lt; <span class="hljs-string">&quot;hello &quot;</span> &lt;&lt; count;<br>msg2.data = ss2.<span class="hljs-built_in">str</span>();<br><br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg.data.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg2.data.<span class="hljs-built_in">c_str</span>());<br><br>chatter_pub.<span class="hljs-built_in">publish</span>(msg);<br>pub2.<span class="hljs-built_in">publish</span>(msg2);<br><br>ros::<span class="hljs-built_in">spinOnce</span>();<br><br>loop_rate.<span class="hljs-built_in">sleep</span>();<br>++count;<br>&#125;<br><br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>订阅端</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">multiReceiver</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">multiReceiver</span>()<br>&#123;<br>sub = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter1&quot;</span>, <span class="hljs-number">1</span>, &amp;multiReceiver::chatterCallback1,<span class="hljs-keyword">this</span>);<br>sub2 = nh.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter2&quot;</span>, <span class="hljs-number">1</span>, &amp;multiReceiver::chatterCallback2,<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>ros::NodeHandle nh;<br>ros::Subscriber sub;<br>ros::Subscriber sub2;<br>  <br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiReceiver::chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span></span>;<span class="hljs-comment">//block chatterCallback2()</span><br>  loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiReceiver::chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>  <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;multi_sub&quot;</span>);<br><br>  multiReceiver recOb;<br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到发布程序中以10hz的频率发布了chatter1和chatter2两个话题，在订阅程序中，回调函数1中加入了2s的延时，导致了回调函数2也只能2s才能接收到一个数据。</p><p>为了使回调函数2也能正常接收数据，就需要在一个ROS节点中开辟多个线程。在ROS中有两种方法可以在一个节点中开辟多个线程。</p><h2 id="ros-MultiThreadedSpinner"><a href="#ros-MultiThreadedSpinner" class="headerlink" title="ros::MultiThreadedSpinner"></a>ros::MultiThreadedSpinner</h2><p>ros::MultiThreadedSpinner类似于ros::spin()，我们可以在它的构造函数中指定线程的数量，如果未指定（或设置为0），它将为每个CPU内核开辟一个线程。</p><p>订阅端使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/thread.hpp&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">multiThreadListener</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">multiThreadListener</span>()<br>&#123;<br>sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter1&quot;</span>, <span class="hljs-number">1</span>, &amp;multiThreadListener::chatterCallback1,<span class="hljs-keyword">this</span>);<br>sub2 = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter2&quot;</span>, <span class="hljs-number">1</span>, &amp;multiThreadListener::chatterCallback2,<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>ros::NodeHandle n;<br>ros::Subscriber sub;<br>ros::Subscriber sub2;<br>  <br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiThreadListener::chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span></span>;<span class="hljs-comment">//block chatterCallback2()</span><br>  loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiThreadListener::chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>  <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;multi_sub&quot;</span>);<br><br>  multiThreadListener listener_obj;<br>  <span class="hljs-function">ros::MultiThreadedSpinner <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>  ros::<span class="hljs-built_in">spin</span>(s);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="ros-AsyncSpinner"><a href="#ros-AsyncSpinner" class="headerlink" title="ros::AsyncSpinner"></a>ros::AsyncSpinner</h2><p>AsyncSpinner比MultiThreadedSpinner更优，它有start()和stop()函数，而不是阻塞的spin()调用，并且在销毁的时候会自动停止。</p><p>订阅端使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/thread.hpp&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">multiThreadListener</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">multiThreadListener</span>()<br>&#123;<br>sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter1&quot;</span>, <span class="hljs-number">1</span>, &amp;multiThreadListener::chatterCallback1,<span class="hljs-keyword">this</span>);<br>sub2 = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter2&quot;</span>, <span class="hljs-number">1</span>, &amp;multiThreadListener::chatterCallback2,<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>ros::NodeHandle n;<br>ros::Subscriber sub;<br>ros::Subscriber sub2;<br>  <br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiThreadListener::chatterCallback1</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span></span>;<span class="hljs-comment">//block chatterCallback2()</span><br>  loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multiThreadListener::chatterCallback2</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>  <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;multi_sub&quot;</span>);<br><br>  multiThreadListener listener_obj;<br>  <br>  <span class="hljs-function">ros::AsyncSpinner <span class="hljs-title">spinner</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// Use 2 threads</span><br>  spinner.<span class="hljs-built_in">start</span>();<br>  ros::<span class="hljs-built_in">waitForShutdown</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning">http://wiki.ros.org/roscpp/Overview/Callbacks%20and%20Spinning</a></li><li><a href="https://www.cnblogs.com/liu-fa/p/5925381.html">ros::spin() 和 ros::spinOnce() 区别及详解</a></li><li><a href="http://t.csdn.cn/9koWB">ros::spin()、ros::spinOnce()：使用细节、区别</a></li><li><a href="http://t.csdn.cn/At3u0">[转]ROS多线程订阅消息(ros::asyncspinner)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python数据结构</title>
    <link href="/2022/10/26/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/10/26/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h1><p>列表数据类型支持很多方法，列表对象的所有方法所示如下：</p><h2 id="list-append-x"><a href="#list-append-x" class="headerlink" title="list.append(x)"></a>list.append(x)</h2><p>在列表末尾添加一个元素</p><h2 id="list-extend-iterable"><a href="#list-extend-iterable" class="headerlink" title="list.extend(iterable)"></a>list.extend(iterable)</h2><p>用可迭代对象的元素扩展列表</p><h2 id="list-insert-i-x"><a href="#list-insert-i-x" class="headerlink" title="list.insert(i, x)"></a>list.insert(i, x)</h2><p>在指定位置插入元素。第一个参数是插入元素的索引</p><h2 id="list-remove-x"><a href="#list-remove-x" class="headerlink" title="list.remove(x)"></a>list.remove(x)</h2><p>从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常。</p><h2 id="list-pop-i"><a href="#list-pop-i" class="headerlink" title="list.pop([i])"></a>list.pop([i])</h2><p>删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素。（方法签名中 i 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）</p><h2 id="list-clear"><a href="#list-clear" class="headerlink" title="list.clear()"></a>list.clear()</h2><p>删除列表里的所有元素</p><h2 id="list-index-x-start-end"><a href="#list-index-x-start-end" class="headerlink" title="list.index(x[, start[, end]])"></a>list.index(x[, start[, end]])</h2><p>返回列表中第一个值为 x 的元素的零基索引。未找到指定元素时，触发 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。</p><h2 id="list-count-x"><a href="#list-count-x" class="headerlink" title="list.count(x)"></a>list.count(x)</h2><p>返回列表中元素 x 出现的次数。</p><h2 id="list-sort-key-x3D-None-reverse-x3D-False"><a href="#list-sort-key-x3D-None-reverse-x3D-False" class="headerlink" title="list.sort(*, key&#x3D;None, reverse&#x3D;False)"></a>list.sort(*, key&#x3D;None, reverse&#x3D;False)</h2><p>就地排序列表中的元素（要了解自定义排序参数，详见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted">sorted()</a>）。</p><h2 id="list-reverse"><a href="#list-reverse" class="headerlink" title="list.reverse()"></a>list.reverse()</h2><p>翻转列表中的元素。</p><h2 id="list-copy"><a href="#list-copy" class="headerlink" title="list.copy()"></a>list.copy()</h2><p>返回列表的浅拷贝。</p><h1 id="2-堆栈"><a href="#2-堆栈" class="headerlink" title="2. 堆栈"></a>2. 堆栈</h1><p>使用列表方法实现堆栈非常容易，最后插入的最先取出（“后进先出”）。把元素添加到堆栈的顶端，使用 append() 。从堆栈顶部取出元素，使用 pop() ，不用指定索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">stack = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 入栈</span><br>stack.append(<span class="hljs-number">6</span>)<br>stack.append(<span class="hljs-number">7</span>)<br><br><span class="hljs-comment"># 出栈</span><br>stack.pop()<br><br><span class="hljs-comment"># 判断栈空</span><br><span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h1><p>列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。</p><p>实现队列最好用 <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.deque">collections.deque</a>, 可以快速从两端添加或删除元素。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collection <span class="hljs-keyword">import</span> deque<br><br>queue = deque([<span class="hljs-string">&quot;Eric&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Michael&quot;</span>])<br><br><span class="hljs-comment"># 入队</span><br>queue.append(<span class="hljs-string">&quot;Terry&quot;</span>)<br>queue.append(<span class="hljs-string">&quot;Graham&quot;</span>)  <br><br><span class="hljs-comment"># 出队</span><br>queue.popleft()   <br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#using-lists-as-queues">https://docs.python.org/zh-cn/3/tutorial/datastructures.html#using-lists-as-queues</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS使用类方法作为回调函数（c++）</title>
    <link href="/2022/10/17/ROS%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/17/ROS%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>大多数教程在示例中使用函数，而不是类方法。这是因为使用函数更简单，而不是因为不支持类方法。</p><p>根据回调函数的定义，其处理的是被调用者的数据，所以一般在调用者那里无法获得回调函数里面的数据，要想在回调函数以外使用回调函数内的数据，目前好像只能借助类来实现了。下面是根据<a href="http://wiki.ros.org/roscpp_tutorials/Tutorials/UsingClassMethodsAsCallbacks">ROS官方教程-使用类方法作为回调函数</a>稍加改动实现的。</p><h1 id="订阅者实现"><a href="#订阅者实现" class="headerlink" title="订阅者实现"></a>订阅者实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;std_msgs/String.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This tutorial demonstrates subscribing to a topic using a class method as the callback.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// %Tag(CLASS_WITH_DECLARATION)%</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Listener</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  std::string copy_data = <span class="hljs-string">&quot;init init init&quot;</span>;<br>  <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_data2</span><span class="hljs-params">()</span></span>&#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Copy data is :&quot;</span> &lt;&lt; copy_data &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;<br>&#125;;<br><span class="hljs-comment">// %EndTag(CLASS_WITH_DECLARATION)%</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Listener::callback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>  std::stringstream ss;<br>  ss &lt;&lt; msg-&gt;data.<span class="hljs-built_in">c_str</span>();<br>  ss &gt;&gt; copy_data;<br>  std::cout &lt;&lt;<span class="hljs-string">&quot;copy_data is: &quot;</span> &lt;&lt; copy_data &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">print_data2</span>();<br>  ++count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener_class&quot;</span>);<br>  ros::NodeHandle n;<br><br><span class="hljs-comment">// %Tag(SUBSCRIBER)%</span><br>  Listener listener;<br>  ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, &amp;Listener::callback, &amp;listener);<br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">// %EndTag(SUBSCRIBER)%</span><br>  <span class="hljs-keyword">while</span>(ros::<span class="hljs-built_in">ok</span>() <span class="hljs-keyword">and</span> listener.count &lt;=<span class="hljs-number">3</span>)&#123;<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;After spin: \n&quot;</span>;<br>  listener.<span class="hljs-built_in">print_data2</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>稍微简单说一下。<strong>listener_class</strong>节点订阅了 <strong>chatter</strong> topic，并绑定<strong>Listener::callback</strong>为回调函数，当有数据过来以后，在回调函数里更新copy_data和count的值，在main函数里面，更新4次后停止对<strong>chatter</strong>的监听，此时再打印类中<strong>copy_data</strong>的值，发现该值已经被更新。更新多少次并没有特别的要求，只是为了退出监听，打印在回调函数中被修改的值看看是否真的被更新了，但是该值一定要比发布者发布的次数低，另外订阅者的刷新频率设高一点，这是为了防止订阅者更新的太慢或要求的次数达不到无法退出监听，就无法调用类中的函数打印我们想要观测的值。</p><p>完整的代码见：<a href="https://github.com/xinwf/useful/tree/master/ros/getDataOutOfCallbackWithClass/src">https://github.com/xinwf/useful/tree/master/ros/getDataOutOfCallbackWithClass/src</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://wiki.ros.org/roscpp_tutorials/Tutorials/UsingClassMethodsAsCallbacks">Using Class Methods as Callbacks</a></li><li><a href="http://t.csdn.cn/l1bEn">ROS从callback中获取数据在回调函数以外使用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS预定义消息类型说明及使用示例（c++）</title>
    <link href="/2022/10/14/ROS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2022/10/14/ROS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ros消息类型，即是ros话题的格式，可视为ros的数据类型，基本上是指同一个意思。ros消息类型是基于C++基本类型封装为.msg文件实现，rosmsg指令用于消息管理。</p><p>所谓预定义消息类型是可以直接引用，不需要自己实现，ros自定义数据类型通常包括两类，一类是在 std_msgs 包下，包含基本数据类型，例如字符型、整型以及浮点型等；一类是在 common_msgs 包下，包含常用的数据类型、例如传感器数据类型、导航数据类型以及几何数据类型等。</p><h1 id="std-msgs功能包"><a href="#std-msgs功能包" class="headerlink" title="std_msgs功能包"></a>std_msgs功能包</h1><p>标准ROS消息包 std_msgs 包括了基本数据类型，是其他各种类型的基础，其他各种消息类型的嵌套定义归根结底都依赖这些基本数据类型。</p><p>std_msgs 官方参考文档：<a href="http://wiki.ros.org/std_msgs">http://wiki.ros.org/std_msgs</a></p><h1 id="common-msgs功能包"><a href="#common-msgs功能包" class="headerlink" title="common_msgs功能包"></a>common_msgs功能包</h1><p>common_msgs包含被其他ROS包广泛使用的消息。这些消息包括了：</p><ul><li><a href="http://wiki.ros.org/actionlib_msgs">actionlib</a>：定义了与 action server 和 action client交互的通用消息。 </li><li><a href="http://wiki.ros.org/diagnostic_msgs">diagnostic_msgs</a>：这个包包含诊断消息，为ROS中的诊断和运行时监控系统提供了标准化的接口。</li><li><a href="http://wiki.ros.org/geometry_msgs">geometry_msgs</a>：是最常用的几何消息类型，定义了描述机器人状态的各种类型，比如点、速度、加速度、位姿等。</li><li><a href="http://wiki.ros.org/nav_msgs">nav_msgs</a>：定义了用于与导航堆栈交互的通用消息。</li><li><a href="http://wiki.ros.org/sensor_msgs">sensor_msgs</a>：定义了常用传感器的消息，包括相机和扫描激光测距仪。</li></ul><p>common_msgs 官方参考文档：<a href="http://wiki.ros.org/common_msgs?distro=noetic">http://wiki.ros.org/common_msgs?distro&#x3D;noetic</a></p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="使用std-msgs中Int8类型消息"><a href="#使用std-msgs中Int8类型消息" class="headerlink" title="使用std_msgs中Int8类型消息"></a>使用std_msgs中Int8类型消息</h2><p>在工作空间中打开终端</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">catkin_create_pkg</span> test3 roscpp rospy std_msgs<br></code></pre></td></tr></table></figure><p>在src文件夹下新建sub_int8.cpp，粘贴以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/Int8.h&quot;</span> <span class="hljs-comment">//#include &quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::Int8::ConstPtr&amp; msg)</span> <span class="hljs-comment">//void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%d]&quot;</span>, msg-&gt;data); <span class="hljs-comment">//ROS_INFO(&quot;I heard: [%f]&quot;, msg-&gt;data.c_str());</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>); <br><br>  ros::NodeHandle n;<br><br>  ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, chatterCallback);<br><br>  ros::<span class="hljs-built_in">spin</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改CMakeLists.txt文件，添加以下语句：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">add_executable</span>(sub_int8 src/sub_int8.cpp)<br><span class="hljs-built_in">target_link_libraries</span>(sub_int8<br>  $&#123;catkin_LIBRARIES&#125;<br>)<br></code></pre></td></tr></table></figure><p>编译后，运行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 打开一个终端</span><br><span class="hljs-attribute">roscore</span><br><br><span class="hljs-comment"># 打开另一个终端</span><br><span class="hljs-attribute">rosrun</span> test3 sub_int8<br><br><span class="hljs-comment"># 打开第三个终端</span><br><span class="hljs-attribute">rostopic</span> pub /chatter std_msgs/Int8 -<span class="hljs-number">1</span> -- <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这里使用了rostopic发布数据，当然也可以创建发布者发布数据，这里给出代码(pub_int8.cpp)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/Int8.h&quot;</span> <span class="hljs-comment">//#include &quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);<br><br>  ros::NodeHandle n;<br><br>  ros::Publisher chatter_pub = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::Int8&gt;(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">//ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);</span><br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>  <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>  &#123;<br>    std_msgs::Int8 msg; <span class="hljs-comment">//std_msgs::String msg;</span><br><br>    <span class="hljs-comment">// std::stringstream ss;</span><br>    <span class="hljs-comment">// ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;</span><br>    <span class="hljs-comment">//注意这里的data，它的数据类型根据消息类型而变</span><br>    <span class="hljs-comment">//具体的参照表参见: http://wiki.ros.org/msg</span><br>    msg.data = count;<span class="hljs-comment">// msg.data = ss.str();</span><br><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%d&quot;</span>, msg.data); <span class="hljs-comment">//ROS_INFO(&quot;%f&quot;, msg.data.c_str())</span><br><br>    chatter_pub.<span class="hljs-built_in">publish</span>(msg);<br><br>    ros::<span class="hljs-built_in">spinOnce</span>();<br><br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>    ++count;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用geometry-msgs中PoseStamped类型消息"><a href="#使用geometry-msgs中PoseStamped类型消息" class="headerlink" title="使用geometry_msgs中PoseStamped类型消息"></a>使用geometry_msgs中PoseStamped类型消息</h2><p>根据上文连接，找到PoseStamped消息类型的文档，如下：</p><img src="/2022/10/14/ROS%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/1.png" class=""><p>可以看出这是一个嵌套定义的消息类型，由两部分组成：</p><ul><li><a href="http://docs.ros.org/en/api/geometry_msgs/html/msg/Pose.html">Pose</a>：指机械臂的位姿。</li><li><a href="http://docs.ros.org/en/api/std_msgs/html/msg/Header.html">Header</a>：带有时间戳。</li></ul><p>发布者（pub_PoseStamped.cpp）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;geometry_msgs/PoseStamped.h&quot;</span> <span class="hljs-comment">//include posestamp head file</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span><span class="hljs-comment">//for sqrt() function</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);<br><br>    ros::NodeHandle n;<br><br>    ros::Publisher chatter_pub = n.<span class="hljs-built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//initialize chatter</span><br><br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    <span class="hljs-comment">//generate pose by ourselves.</span><br>    <span class="hljs-type">double</span> positionX, positionY, positionZ;<br>    <span class="hljs-type">double</span> orientationX, orientationY, orientationZ, orientationW;<br><br>    <span class="hljs-comment">//We just make the robot has fixed orientation. Normally quaternion needs to be normalized, which means x^2 + y^2 + z^2 +w^2 = 1</span><br>    <span class="hljs-type">double</span> fixedOrientation = <span class="hljs-number">0.1</span>;<br>    orientationX = fixedOrientation ;<br>    orientationY = fixedOrientation ;<br>    orientationZ = fixedOrientation ;<br>    orientationW = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - <span class="hljs-number">3.0</span>*fixedOrientation*fixedOrientation); <br><br>    <span class="hljs-type">double</span> count = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>())<br>    &#123;<br>        <span class="hljs-comment">//We just make the position x,y,z all the same. The X,Y,Z increase linearly</span><br>        positionX = count;<br>        positionY = count;<br>        positionZ = count;<br><br>        geometry_msgs::PoseStamped msg; <br><br>        <span class="hljs-comment">//assign value to poseStamped</span><br><br>            <span class="hljs-comment">//First assign value to &quot;header&quot;.</span><br>        ros::Time currentTime = ros::Time::<span class="hljs-built_in">now</span>();<br>        msg.header.stamp = currentTime;<br><br>            <span class="hljs-comment">//Then assign value to &quot;pose&quot;, which has member position and orientation</span><br>        msg.pose.position.x = positionX;<br>        msg.pose.position.y = positionY;<br>        msg.pose.position.z = positionY;<br><br>        msg.pose.orientation.x = orientationX;<br>        msg.pose.orientation.y = orientationY;<br>        msg.pose.orientation.z = orientationZ;<br>        msg.pose.orientation.w = orientationW;<br><br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;we publish the robot&#x27;s position and orientaion&quot;</span>); <br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the position(x,y,z) is %f , %f, %f&quot;</span>, msg.pose.position.x, msg.pose.position.y, msg.pose.position.z);<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the orientation(x,y,z,w) is %f , %f, %f, %f&quot;</span>, msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w);<br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the time we get the pose is %f&quot;</span>,  msg.header.stamp.sec + <span class="hljs-number">1e-9</span>*msg.header.stamp.nsec);<br><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;\n \n&quot;</span>&lt;&lt;std::endl; <span class="hljs-comment">//add two more blank row so that we can see the message more clearly</span><br><br>        chatter_pub.<span class="hljs-built_in">publish</span>(msg);<br><br>        ros::<span class="hljs-built_in">spinOnce</span>();<br><br>        loop_rate.<span class="hljs-built_in">sleep</span>();<br><br>        ++count;<br>    &#125;<br><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>订阅者（sub_PoseStamped.cpp）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;geometry_msgs/PoseStamped.h&quot;</span> </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> <span class="hljs-comment">//Note it is geometry_msgs::PoseStamped, not std_msgs::PoseStamped</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard the pose from the robot&quot;</span>); <br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the position(x,y,z) is %f , %f, %f&quot;</span>, msg-&gt;pose.position.x, msg-&gt;pose.position.y, msg-&gt;pose.position.z);<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the orientation(x,y,z,w) is %f , %f, %f, %f&quot;</span>, msg-&gt;pose.orientation.x, msg-&gt;pose.orientation.y, msg-&gt;pose.orientation.z, msg-&gt;pose.orientation.w);<br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;the time we get the pose is %f&quot;</span>,  msg-&gt;header.stamp.sec + <span class="hljs-number">1e-9</span>*msg-&gt;header.stamp.nsec);<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;\n \n&quot;</span>&lt;&lt;std::endl; <span class="hljs-comment">//add two more blank row so that we can see the message more clearly</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>    ros::NodeHandle n;<br><br>    ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">10</span>, chatterCallback);<br><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改CMakeLists.txt：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss">...<br># 添加依赖<br><span class="hljs-built_in">find_package</span>(catkin REQUIRED COMPONENTS<br>  roscpp<br>  rospy<br>  std_msgs<br>  geometry_msgs<br>)<br><br>...<br><br><span class="hljs-built_in">add_executable</span>(pub_PoseStamped src/pub_PoseStamped.cpp)<br><span class="hljs-built_in">add_executable</span>(sub_PoseStamped src/sub_PoseStamped.cpp)<br><br><span class="hljs-built_in">target_link_libraries</span>(pub_PoseStamped<br>  $&#123;catkin_LIBRARIES&#125;<br>)<br><span class="hljs-built_in">target_link_libraries</span>(sub_PoseStamped<br>  $&#123;catkin_LIBRARIES&#125;<br>)<br></code></pre></td></tr></table></figure><p>编译后，运行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/94338630">ROS 消息</a></li><li><a href="https://blog.csdn.net/qq_30193419/article/details/111867500">详解常用的ROS内置消息类型</a></li><li><a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29">编写简单的发布者和订阅者（C++）</a></li><li><a href="https://www.guyuehome.com/14319">ROS:从入门到放弃(二)　发布接收不同类型消息1</a></li><li><a href="https://www.guyuehome.com/14553">机器人操作系统ROS:从入门到放弃(三)　发布接收不同消息2</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Moveit编程实现机械臂运动(c++接口)</title>
    <link href="/2022/10/13/Moveit%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%A2%B0%E8%87%82%E8%BF%90%E5%8A%A8-c-%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/13/Moveit%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%A2%B0%E8%87%82%E8%BF%90%E5%8A%A8-c-%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p>在Moveit中，有三个主要的控制接口去控制机械臂，如下图：</p><img src="/2022/10/13/Moveit%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%A2%B0%E8%87%82%E8%BF%90%E5%8A%A8-c-%E6%8E%A5%E5%8F%A3/1.png" class=""><p>刚接触Moveit时，一般是从RViz图形界面拖动机械臂末端开始学习控制。但实际上大部分工作都需要通过编程实现，本文主要介绍机械臂的c++接口，使用move_group_interface实现机械臂的正逆运动学控制。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本文所使用的机械臂是官网教程使用的panda机械臂，所以需要用到panda_moveit_config包。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ros-planning/</span>panda_moveit_config.git -b melodic-devel<br></code></pre></td></tr></table></figure><p>创建自己的功能包，用于控制机械臂。在终端中打开自己的工作空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src<br><span class="hljs-comment"># 所需要的依赖后面修改文件再做添加。</span><br>catkin_create_pkg test2 roscpp<br></code></pre></td></tr></table></figure><p>然后再src文件夹下，创建test2.cpp文件。</p><h1 id="编程目标"><a href="#编程目标" class="headerlink" title="编程目标"></a>编程目标</h1><p>先使用世界坐标控制机械臂到某一位置，再使用关节坐标控制机械臂到另一目标位置。</p><h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><p><strong>c++代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit/move_group_interface/move_group_interface.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit/planning_scene_interface/planning_scene_interface.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit_msgs/DisplayRobotState.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit_msgs/DisplayTrajectory.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit_msgs/AttachedCollisionObject.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit_msgs/CollisionObject.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;moveit_visual_tools/moveit_visual_tools.h&gt;</span></span><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> tau = <span class="hljs-number">2</span>*M_PI;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//声明一个节点</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;move_group_interface_tutorial&quot;</span>);<br>    ros::NodeHandle node_handle;<br>    <span class="hljs-comment">//开启线程</span><br>    <span class="hljs-function">ros::AsyncSpinner <span class="hljs-title">spinner</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    spinner.<span class="hljs-built_in">start</span>();<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string PLANNING_GROUP = <span class="hljs-string">&quot;panda_arm&quot;</span>;<br>    moveit::<span class="hljs-function">planning_interface::MoveGroupInterface <span class="hljs-title">move_group_interface</span><span class="hljs-params">(PLANNING_GROUP)</span></span>;<br>    <span class="hljs-comment">// 用于在虚拟世界中添加碰撞对象</span><br>    <span class="hljs-comment">// moveit::planning_interface::PlanningSceneInterface planning_scene_interface;</span><br><br>    <span class="hljs-type">const</span> moveit::core::JointModelGroup* joint_model_group =<br>      move_group_interface.<span class="hljs-built_in">getCurrentState</span>()-&gt;<span class="hljs-built_in">getJointModelGroup</span>(PLANNING_GROUP);<br><br><br>    <span class="hljs-comment">//获得基本信息</span><br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;Planning frame: %s&quot;</span>, move_group_interface.<span class="hljs-built_in">getPlanningFrame</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;End effector link: %s&quot;</span>, move_group_interface.<span class="hljs-built_in">getEndEffectorLink</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;Available Planning Groups:&quot;</span>);<br>    std::<span class="hljs-built_in">copy</span>(move_group_interface.<span class="hljs-built_in">getJointModelGroupNames</span>().<span class="hljs-built_in">begin</span>(),<br>            move_group_interface.<span class="hljs-built_in">getJointModelGroupNames</span>().<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">ostream_iterator</span>&lt;std::string&gt;(std::cout, <span class="hljs-string">&quot;, &quot;</span>));<br>    <br><br>    geometry_msgs::Pose target_pose1;<br>    target_pose1.orientation.w = <span class="hljs-number">1.0</span>;<br>    target_pose1.orientation.x = <span class="hljs-number">0.0</span>;<br>    target_pose1.orientation.y = <span class="hljs-number">0.0</span>;<br>    target_pose1.orientation.z = <span class="hljs-number">0.0</span>;<br>    target_pose1.position.x = <span class="hljs-number">0.28</span>;<br>    target_pose1.position.y = <span class="hljs-number">-0.2</span>;<br>    target_pose1.position.z = <span class="hljs-number">0.5</span>;<br>    move_group_interface.<span class="hljs-built_in">setPoseTarget</span>(target_pose1);<br><br>    <span class="hljs-comment">//规划</span><br>    moveit::planning_interface::MoveGroupInterface::Plan my_plan;<br>    <span class="hljs-type">bool</span> success = (move_group_interface.<span class="hljs-built_in">plan</span>(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);<br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;Visualizing plan 1 (pose goal) %s&quot;</span>, success ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;FAILED&quot;</span>);<br><br>    <span class="hljs-comment">//可视化</span><br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;Visualizing plan 1 as trajectory line&quot;</span>);<br>    <span class="hljs-comment">//规划+运动</span><br>    move_group_interface.<span class="hljs-built_in">move</span>();<br><br><br>    <span class="hljs-comment">//关节空间目标</span><br>    moveit::core::RobotStatePtr current_state = move_group_interface.<span class="hljs-built_in">getCurrentState</span>();<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; joint_group_positions;<br>    current_state-&gt;<span class="hljs-built_in">copyJointGroupPositions</span>(joint_model_group, joint_group_positions);<br>    <span class="hljs-comment">// joint_group_positions[0] = -tau / 6;  // -1/6 turn in radians</span><br>    joint_group_positions[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    joint_group_positions[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    joint_group_positions[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    joint_group_positions[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>    joint_group_positions[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>    joint_group_positions[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;<br>    move_group_interface.<span class="hljs-built_in">setJointValueTarget</span>(joint_group_positions);<br>    <span class="hljs-comment">//设置速度与加速度限制</span><br>    move_group_interface.<span class="hljs-built_in">setMaxVelocityScalingFactor</span>(<span class="hljs-number">0.05</span>);<br>    move_group_interface.<span class="hljs-built_in">setMaxAccelerationScalingFactor</span>(<span class="hljs-number">0.05</span>);<br><br>    success = (move_group_interface.<span class="hljs-built_in">plan</span>(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);<br>    <span class="hljs-built_in">ROS_INFO_NAMED</span>(<span class="hljs-string">&quot;tutorial&quot;</span>, <span class="hljs-string">&quot;Visualizing plan 2 (joint space goal) %s&quot;</span>, success ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;FAILED&quot;</span>);<br>    move_group_interface.<span class="hljs-built_in">move</span>();<br><br><br>    ros::<span class="hljs-built_in">shutdown</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行程序之前需要修改CMakeLists.txt，添加必要依赖：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.0</span><span class="hljs-number">.2</span>)<br>project(test2)<br><br>find_package(catkin REQUIRED COMPONENTS<br>  interactive_markers<br>  roscpp<br>  moveit_core<br>  moveit_ros_planning<br>  moveit_ros_planning_interface<br>  moveit_ros_perception<br>  rviz_visual_tools<br>  moveit_visual_tools<br>  pluginlib<br>  geometric_shapes<br>  pcl_ros<br>  pcl_conversions<br>  rosbag<br>  tf2_ros<br>  tf2_eigen<br>  tf2_geometry_msgs<br>)<br><br>catkin_package(<br>#  INCLUDE_DIRS include<br>#  LIBRARIES test2<br>#  CATKIN_DEPENDS roscpp<br>#  DEPENDS system_lib<br>)<br><br>include_directories(<br><span class="hljs-meta"># <span class="hljs-keyword">include</span></span><br>  $&#123;catkin_INCLUDE_DIRS&#125;<br>)<br>add_executable(test2 src/test2.cpp)<br>target_link_libraries(test2<br>  $&#123;catkin_LIBRARIES&#125;<br>)<br></code></pre></td></tr></table></figure><blockquote><p>本来我觉得package.xml文件也要修改，但发现不修改也不应node的执行。这里先留个坑。</p></blockquote><h1 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h1><p>在工作空间目录下，打开一个终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_make<br><br><span class="hljs-built_in">source</span> devel/setup.bash<br><br>roslaunch panda_moveit_config demo.launch <br></code></pre></td></tr></table></figure><p>再打开另一个终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br><br>rosrun test2 test2 <br></code></pre></td></tr></table></figure><p>在RViz中可以看到，机械臂运行情况。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://ros-planning.github.io/moveit_tutorials/doc/move_group_interface/move_group_interface_tutorial.html#">Move Group C++ Interface</a></li><li><a href="https://github.com/ros-planning/moveit_tutorials/blob/master/doc/move_group_interface/src/move_group_interface_tutorial.cpp">move_group_interface_tutorial.cpp</a></li><li><a href="https://blog.csdn.net/gyxx1998/article/details/119061327">UR机械臂学习（7-1）：MoveIt简单编程实现机械臂运动（正逆运动学）</a></li><li><a href="https://www.guyuehome.com/455/clip_image006_thumb-png-2">ROS探索总结（二十六）——MoveIt编程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
      <category>moveit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>launch文件学习笔记</title>
    <link href="/2022/10/10/launch%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/10/launch%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>每当我们需要运行一个ROS节点或工具时，都需要打开一个新的终端运行一个命令。当系统中的节点数量不断增加时，每个节点一个终端的模式会变得非常麻烦。那么有没有一种方式可以一次性启动所有节点呢？答案当然是肯定的。 启动文件（Launch File）便是ROS中一种同时启动多个节点的途径，还可以自动启动ROSMaster节点管理器，而且可以实现每个节点的各种配置，为多个节点的操作提供了很大便利。</p><h1 id="一、基本元素"><a href="#一、基本元素" class="headerlink" title="一、基本元素"></a>一、基本元素</h1><p>首先来看一个简单的launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>   &lt;nodepkg=&quot;turtlesim&quot;name=&quot;sim1&quot; type=&quot;turtlesim_node&quot;/&gt;<br>   &lt;nodepkg=&quot;turtlesim&quot;name=&quot;sim2&quot; type=&quot;turtlesim_node&quot;/&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一个简单而完整的launch文件，采用XML的形式进行描述，包含一个根元素&lt;launch&gt;和两个节点元素&lt;node&gt;。</p><h2 id="1-lt-launch-gt"><a href="#1-lt-launch-gt" class="headerlink" title="1. &lt;launch&gt;"></a>1. &lt;launch&gt;</h2><p>XML文件必须要包含一个根元素，launch文件中的根元素采用&lt;launch&gt;标签定义，文件中的其他内容都必须包含在这个标签之中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-lt-node-gt"><a href="#2-lt-node-gt" class="headerlink" title="2. &lt;node&gt;"></a>2. &lt;node&gt;</h2><p>启动文件的核心是启动ROS节点，采用&lt;node&gt;标签定义，语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;package-name&quot;</span><span class="hljs-attr">type</span>=<span class="hljs-string">&quot;executable-name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;node-name&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>从上边的定义规则可以看出，在启动文件中启动一个节点需要三个属性：pkg、type和name。其中pkg定义节点所在的功能包名称，type定义节点的可执行文件名称，这两个属性等同于在终端中使用rosrun命令执行节点时的输入参数。name属性用来定义节点运行的名称，将覆盖节点中init()赋予节点的名称。这是三个最常用的属性，在某些情况下，我们还有可能用到以下属性：</p><ul><li>output &#x3D; “screen”：将节点的标准输出打印到终端屏幕，默认输出为日志文档;</li><li>respawn &#x3D; “true”：复位属性，该节点停止时，会自动重启，默认为false;</li><li>required &#x3D; “true”：必要节点，当该节点终止时，launch文件中的其他节点也被终止;</li><li>ns &#x3D; “namespace”：命名空间，为节点内的相对名称添加命名空间前缀;</li><li>args &#x3D; “arguments”：节点需要的输入参数。</li></ul><p>实际应用中的launch文件往往会更加复杂，使用的标签也会更多，例如一个启动机器人的launch文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;mrobot_bringup&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;mrobot_bringup&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mrobot_bringup&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;urdf_file&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;$(find xacro)/xacro --inorder &#x27;$(find mrobot_description)/urdf/mrobot_with_rplidar.urdf.xacro&#x27;&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_description&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;$(arg urdf_file)&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;</span>  <br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;state_publisher&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;publish_frequency&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;double&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5.0&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base2laser&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;tf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;static_transform_publisher&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;0 0 0 0 0 0 1 /base_link /laser 50&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_pose_ekf&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_pose_ekf&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_pose_ekf&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;robot_pose_ekf/odom_combined&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;odom_combined&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;freq&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10.0&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sensor_timeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1.0&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;publish_tf&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;odom_used&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;imu_used&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vo_used&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;output_frame&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;odom&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(find mrobot_bringup)/launch/rplidar.launch&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>目前，我们只关注其中的标签元素，除了上边介绍的&lt;launch&gt;和&lt;node&gt;，这里还出现了&lt;arg&gt;、&lt;param&gt;、&lt;remap&gt;，这些都是常用的标签元素。</p><h1 id="二、参数设置"><a href="#二、参数设置" class="headerlink" title="二、参数设置"></a>二、参数设置</h1><p>为了方便设置和修改，launch文件支持参数设置的功能，类似于编程语言中的变量声明。关于参数设置的标签元素有两个：&lt;param&gt;、&lt;arg&gt;，一个代表parameter，另一个代表argument。这两个标签元素翻译成中文都是“参数”的意思，但是这两个“参数”的意义是完全不同的。</p><h2 id="1-lt-param-gt"><a href="#1-lt-param-gt" class="headerlink" title="1. &lt;param&gt;"></a>1. &lt;param&gt;</h2><p>parameter是ROS系统运行中的参数，存储在参数服务器中。在launch文件中通过&lt;param&gt;元素加载parameter；launch文件执行后，parameter就加载到ROS的参数服务器上了。每个活跃的节点都可以通过 ros::param::get()接口来获取parameter的值，用户也可以在终端中通过rosparam命令获得parameter的值。 &lt;param&gt;的使用方法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;output_frame&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;odom&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>运行launch文件后，output_frame这个parameter的值就设置为odom，并且加载到ROS参数服务器上了。但是在很多复杂的系统中，参数的数量很多，如果这样一个一个的设置会非常麻烦，ROS也为我们提供了另外一种类似的参数加载方式——&lt;rosparam&gt;：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;rosparamfile=&quot;$(find 2dnav_pr2)/config/costmap_common_params.yaml&quot; command=&quot;load&quot; ns=&quot;local_costmap&quot; /&gt;<br></code></pre></td></tr></table></figure><p>&lt;rosparam&gt;可以帮助我们将一个yaml格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为“load”，还可以选择设置命名空间“ns”。  </p><h2 id="2-lt-arg-gt"><a href="#2-lt-arg-gt" class="headerlink" title="2. &lt;arg&gt;"></a>2. &lt;arg&gt;</h2><p>argument是另外一个概念，类似于launch文件内部的局部变量，仅限于launch文件使用，便于launch文件的重构，和ROS节点内部的实现没有关系。 设置argument使用&lt;arg&gt;标签元素，语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”arg-name”</span> <span class="hljs-attr">default</span>=<span class="hljs-string">”arg-value”/</span>&gt;</span><br></code></pre></td></tr></table></figure><p>launch文件中需要使用到argument时，可以使用如下方式调用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;paramname=&quot;foo&quot; value=&quot;$(argarg-name)&quot; /&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;node&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;package&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;type &quot;</span><span class="hljs-attr">args</span>=<span class="hljs-string">&quot;$(arg arg-name)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="三、重映射机制"><a href="#三、重映射机制" class="headerlink" title="三、重映射机制"></a>三、重映射机制</h1><p>ROS的设计目标是提高代码的复用率，所以ROS社区中的很多功能包我们都可以拿来直接使用，而不需要关注功能包的内部实现。那么问题就来了，别人功能包的接口不一定和我们的系统兼容呀？ ROS提供一种重映射的机制，简单来说就是取别名，类似于C++中的别名机制，我们不需要修改别人功能包的接口，只需要将接口名称重映射一下，取个别名，我们的系统就认识了（接口的数据类型必须相同）。launch文件中的&lt;remap&gt;标签可以帮我们实现这个重映射的功能。 比如turtlebot的键盘控制节点，发布的速度控制指令话题可能是&#x2F;turtlebot&#x2F;cmd_vel，但是我们自己的机器人订阅的速度控制话题是&#x2F;cmd_vel，这个时候使用&lt;remap&gt;就可以轻松解决问题，将&#x2F;turtlebot &#x2F;cmd_vel重映射为&#x2F;cmd_vel，我们的机器人就可以接收到速度控制指令了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;/turtlebot/cmd_vel&quot;</span><span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/cmd_vel&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>重映射机制在ROS中的使用非常广泛，也非常重要，方法不止这一种，也可以在终端rosrun命令中实现重映射，大家一定要理解好这种机制。</p><h1 id="四、嵌套复用"><a href="#四、嵌套复用" class="headerlink" title="四、嵌套复用"></a>四、嵌套复用</h1><p>在复杂的系统当中，launch文件往往有很多，这些launch文件之间也会存在依赖关系。如果需要直接复用一个已有launch文件中的内容，可以使用&lt;include&gt;标签包含其他launch文件，这和C语言中的include几乎是一样的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;$(dirname)/other.launch&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>总而言之，launch是ROS框架中非常实用、灵活的功能，它类似于一种高级编程语言，可以帮助我们管理启动系统时的方方面面。在使用ROS的过程中，很多情况下我们并不需要编写大量代码，仅需要使用已有的功能包，编辑一下launch文件，就可以完成很多机器人功能。  </p><blockquote><p>这里仅介绍了launch中最为常用的一些标签元素，还有更多高级的标签元素可以访问wiki学习： <a href="http://wiki.ros.org/roslaunch/XML">http://wiki.ros.org/roslaunch/XML</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python编程技巧</title>
    <link href="/2022/10/08/python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/10/08/python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="编程技巧持续总结"><a href="#编程技巧持续总结" class="headerlink" title="编程技巧持续总结"></a>编程技巧持续总结</h1><h2 id="1-根据列表值排序下标"><a href="#1-根据列表值排序下标" class="headerlink" title="1. 根据列表值排序下标"></a>1. 根据列表值排序下标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 存在一个列表nums1，根据其列表值排序下标</span><br>nums1 = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br>n=<span class="hljs-built_in">len</span>(nums1)<br>idx1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>idx1.sort(key=<span class="hljs-keyword">lambda</span> x: nums1[x])<br><span class="hljs-built_in">print</span>(idx1)<br></code></pre></td></tr></table></figure><p>小试牛刀：</p><ol><li><a href="https://leetcode.cn/problems/advantage-shuffle/">https://leetcode.cn/problems/advantage-shuffle/</a></li></ol><h2 id="2-同时列出数据和数据下标"><a href="#2-同时列出数据和数据下标" class="headerlink" title="2. 同时列出数据和数据下标"></a>2. 同时列出数据和数据下标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用enumerate()</span><br>nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> i,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>    <span class="hljs-built_in">print</span> i,num<br></code></pre></td></tr></table></figure><h2 id="3-单调栈"><a href="#3-单调栈" class="headerlink" title="3. 单调栈"></a>3. 单调栈</h2><p>单调栈顾名思义，即满足单调性的栈结构。单调栈基本定义：<a href="https://oi-wiki.org/ds/monotonous-stack/">https://oi-wiki.org/ds/monotonous-stack/</a></p><p>单调栈可用于寻找数组中某个元素x左边（右边）第一个小于x的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">11</span>,<span class="hljs-number">81</span>,<span class="hljs-number">94</span>,<span class="hljs-number">43</span>,<span class="hljs-number">3</span>]<br>n = lne(arr)<br>monoStack = []  <span class="hljs-comment"># 定义一个单调栈</span><br>left = [<span class="hljs-number">0</span>] * n   <span class="hljs-comment"># 寻找每个元素左边第一个小于x的下标</span><br><br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>    <span class="hljs-keyword">while</span> monoStack <span class="hljs-keyword">and</span> x &lt;= arr[monoStack[-<span class="hljs-number">1</span>]]:<br>        monoStack.pop()<br>    left[i] = (monoStack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> monoStack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)  <span class="hljs-comment"># -1表示不存在</span><br>    monoStack.append(i)<br><span class="hljs-built_in">print</span>(left)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch入门学习笔记</title>
    <link href="/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><ol><li><a href="https://pytorch.org/tutorials/">官网教程</a></li><li><a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">PyTorch深度学习：60分钟入门</a></li><li><a href="https://pytorch123.com/">PyTorch教程中文版</a></li><li><a href="http://fancyerii.github.io/books/pytorch/#60%E5%88%86%E9%92%9Fpytorch%E6%95%99%E7%A8%8B">PyTorch简明教程</a></li></ol><h1 id="什么是PyTorch？"><a href="#什么是PyTorch？" class="headerlink" title="什么是PyTorch？"></a>什么是PyTorch？</h1><p>PyTorch是一个基于python的科学计算包，有两个主要目的:</p><ul><li>NumPy的替代品，可以使用gpu和其他加速器的功能。</li><li>一个用于实现神经网络的自动微分库。</li></ul><h1 id="TENSORS"><a href="#TENSORS" class="headerlink" title="TENSORS"></a>TENSORS</h1><p>Tensors是一种特殊的数据结构，非常类似于数组和矩阵。在PyTorch中，我们使用tensors取编码模型的输入和输出，以及模型的参数。</p><p>Tensors与NumPy的ndarray相似，不同之处是tensors可以在GPU或者其它专门的硬件上运行，以加速计算。如果你熟悉ndarray，你就会对Tensor API很熟悉。如果没有，请跟随本API快速演练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="Tensor-Initialization"><a href="#Tensor-Initialization" class="headerlink" title="Tensor Initialization"></a>Tensor Initialization</h2><p>Tensors可以用各种方式初始化。看看下面的例子:</p><h3 id="Directly-from-data"><a href="#Directly-from-data" class="headerlink" title="Directly from data"></a>Directly from data</h3><p>Tensors可以直接从数据中创建。数据类型被自动推断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>x_data = torch.tensor(data)<br></code></pre></td></tr></table></figure><h3 id="From-a-NumPy-array"><a href="#From-a-NumPy-array" class="headerlink" title="From a NumPy array"></a>From a NumPy array</h3><p>Tensors可以从NumPy数组创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np_array = np.array(data)<br>x_np = torch.from_numpy(np_array)<br></code></pre></td></tr></table></figure><h3 id="From-another-tensor"><a href="#From-another-tensor" class="headerlink" title="From another tensor"></a>From another tensor</h3><p>新创建的tensor保留参数tensor的属性(形状、数据类型)，除非显式重写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x_ones = torch.ones_like(x_data) <span class="hljs-comment"># retains the properties of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;x_ones&#125;</span> \n&quot;</span>)<br><br>x_rand = torch.rand_like(x_data, dtype=torch.<span class="hljs-built_in">float</span>) <span class="hljs-comment"># overrides the datatype of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;x_rand&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="With-random-or-constant-values"><a href="#With-random-or-constant-values" class="headerlink" title="With random or constant values"></a>With random or constant values</h3><p>shape 是tensor维度的元组表示。在下面的函数中国，它决定了输出tensor的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">shape = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>,)<br>rand_tensor = torch.rand(shape)<br>ones_tensor = torch.ones(shape)<br>zeros_tensor = torch.zeros(shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Zeros Tensor: \n <span class="hljs-subst">&#123;zeros_tensor&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Tensor-Attributes"><a href="#Tensor-Attributes" class="headerlink" title="Tensor Attributes"></a>Tensor Attributes</h2><p>Tensor 属性包含形状，数据类型，以及存储它们的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of tensor: <span class="hljs-subst">&#123;tensor.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Datatype of tensor: <span class="hljs-subst">&#123;tensor.dtype&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device tensor is stored on: <span class="hljs-subst">&#123;tensor.device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Tensor-Operation"><a href="#Tensor-Operation" class="headerlink" title="Tensor Operation"></a>Tensor Operation</h2><p>有超过100种tensor操作，包括转置，索引，切片，数学操作，线性代数，随机抽样。更多描述点击<a href="https://pytorch.org/docs/stable/torch.html">这里</a>。它们都可以在GPU上运行（速度通常比CPU快）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># We move our tensor to the GPU if available</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>  tensor = tensor.to(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device tensor is stored on: <span class="hljs-subst">&#123;tensor.device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面是一些常用操作：<br><strong>Standard numpy-like indexing and slicing:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.ones(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>tensor[:,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><p><strong>Joining tensors:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1)<br></code></pre></td></tr></table></figure><p><strong>Multiplying tensors:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This computes the element-wise product</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tensor.mul(tensor) \n <span class="hljs-subst">&#123;tensor.mul(tensor)&#125;</span> \n&quot;</span>)<br><span class="hljs-comment"># Alternative syntax:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tensor * tensor \n <span class="hljs-subst">&#123;tensor * tensor&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面是计算对应元素相乘，下面是计算矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tensor.matmul(tensor.T) \n <span class="hljs-subst">&#123;tensor.matmul(tensor.T)&#125;</span> \n&quot;</span>)<br><span class="hljs-comment"># Alternative syntax:</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tensor @ tensor.T \n <span class="hljs-subst">&#123;tensor @ tensor.T&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>In-place operations:</strong><br>带有后缀’<em>‘的操作可以改变变量的值。如x.copy_y),x.t</em>()将改变x。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(tensor, <span class="hljs-string">&quot;\n&quot;</span>)<br>tensor.add_(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><blockquote><p>注意：此操作可以节省内存，但在计算导数时可能会出现问题，因为会立即丢失历史记录。因此，不鼓励使用它们。</p></blockquote><h2 id="Bridge-with-Numpy"><a href="#Bridge-with-Numpy" class="headerlink" title="Bridge with Numpy"></a>Bridge with Numpy</h2><p>CPU上的tensor和NumPy数组可以共享它们的底层内存位置，更改其中一个将更改另一个。</p><h3 id="Tensor-to-Numpy-array"><a href="#Tensor-to-Numpy-array" class="headerlink" title="Tensor to Numpy array"></a>Tensor to Numpy array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.ones(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br>n = t.numpy()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在tensor上的改变影响Numpy数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t.add_(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Numpy-array-to-Tensor"><a href="#Numpy-array-to-Tensor" class="headerlink" title="Numpy array to Tensor"></a>Numpy array to Tensor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">n = np.ones(<span class="hljs-number">5</span>)<br>t = torch.from_numpy(n)<br></code></pre></td></tr></table></figure><p>在Numpy数组上的改变影响tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.add(n, <span class="hljs-number">1</span>, out=n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="torch-autograd简要介绍"><a href="#torch-autograd简要介绍" class="headerlink" title="torch.autograd简要介绍"></a>torch.autograd简要介绍</h1><p>torch.autograd是PyTorch的自动微分引擎，为神经网络的训练提供动力。在本节中，您将从概念上了解autograd如何帮助神经网路训练。</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>神经网路(NNs)是在处理输入数据的嵌套函数的集合。这些函数由参数（包括weights和biases），在PyTorch种，这些参数存储在tensor中。</p><p>训练一个神经网络需要两个步骤：</p><ul><li>Forward Propagation(前向传播)</li><li>Backward Propagation(反向传播)<br><a href="https://www.bilibili.com/video/BV1yG411x7Cc/?spm_id_from=333.337.search-card.all.click&vd_source=022f3c5b161a608af769be0a019cdc1a">[5分钟深度学习] #02 反向传播算法</a></li></ul><h2 id="Usage-in-PyTorch"><a href="#Usage-in-PyTorch" class="headerlink" title="Usage in PyTorch"></a>Usage in PyTorch</h2><p>让我们来看一个单独的训练步骤。在这个例子中，我们从torchvision加载一个预训练的resnet18模型。我们创建一个随机的tensor数据来表示一个图像：3通道，高64，宽64。并且其对应的标签被初始化一些随机值，预训练中标签的形状为（1，1000）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18, ResNet18_Weights<br>model = resnet18(weights=ResNet18_Weights.DEFAULT)<br>data = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>labels = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>接下来，我们将输入的数据通过模型的每一层来进行预测。这是”forward pass”.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">prediction = model(data) <span class="hljs-comment"># forward pass</span><br></code></pre></td></tr></table></figure><p>我们使用模型的预测和相应的标签来计算误差(loss)。下一步是通过网络反向传播这个误差。当我们在误差tensor上调用 .backward() 函数时，反向传播被启动。Autograd然后计算并存储每个模型参数的梯度，存放在参数的 .grad 属性中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = (prediction - labels).<span class="hljs-built_in">sum</span>()<br>loss.backward() <span class="hljs-comment"># backward pass</span><br></code></pre></td></tr></table></figure><p>接下来，我们加载一个优化器(optimizer)，在本例中，SGD的学习率为0.01，动量为0.9。我们在优化器中注册模型的所有参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optim = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">1e-2</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure><p>最后，我们调用 .step() 来启动梯度下降。优化器通过存储在 .grad 中的梯度来调整每个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optim.step() <span class="hljs-comment">#gradient descent</span><br></code></pre></td></tr></table></figure><p>至此，你就有了训练神经网络所需的一切。下面是autograd的详细的工作原理，可以跳过。</p><h2 id="Differentiation-in-Autograd"><a href="#Differentiation-in-Autograd" class="headerlink" title="Differentiation in Autograd"></a>Differentiation in Autograd</h2><p>让我们看看autograd是如何收集梯度的。我们用 requires_grad&#x3D;True 创建两个tensor，a和b。这向autograd发出信号，表示对它们的每个操作都应该被跟踪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>a = torch.tensor([<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor([<span class="hljs-number">6.</span>, <span class="hljs-number">4.</span>], requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>我们创建另一个tensor, Q.<br>$$ Q &#x3D; 3a^3 - b^2$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Q = <span class="hljs-number">3</span>*a**<span class="hljs-number">3</span> - b**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>我们假设a和b是一个神经网络的参数，Q是误差。在神经网路训练中，我们需要误差对于所有参数的梯度。即：<br>$$ \frac{\partial Q}{\partial a} &#x3D; 9a^2 $$<br>$$ \frac{\partial Q}{\partial b} &#x3D; -2b $$</p><p>当我们在 Q 上调用 .backward() 函数时，autograd 会计算这些梯度并存储结果到各自的 .grad 属性上。</p><p>我们需要显式的在 Q.backward() 上传递一个梯度参数，因为它是一个向量。梯度是和 Q 相同形状的tensor，并且它表示 Q 相对于它本身的梯度。<br>$$ \frac{\partial Q}{\partial Q} &#x3D; 1 $$</p><p>同样，我们也可以将 Q 聚合为一个标量并隐式的向后调用，像 Q.sum().backward()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">external_grad = torch.tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>Q.backward(gradient=external_grad)<br></code></pre></td></tr></table></figure><p>梯度值现在保存在 a.grad 和 b.grad 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># check if collected gradients are correct</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">9</span>*a**<span class="hljs-number">2</span> == a.grad)<br><span class="hljs-built_in">print</span>(-<span class="hljs-number">2</span>*b == b.grad)<br></code></pre></td></tr></table></figure><h2 id="Computational-Graph"><a href="#Computational-Graph" class="headerlink" title="Computational Graph"></a>Computational Graph</h2><p>从概念上讲，autograd在一个由<a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.Function">Function</a>对象组成的有向无环图(DAG)中保存了数据(tensor)和所有执行的操作(伴随着产生的tensor)。在这个DAG中，叶子是输入tensor，根是输出tensor。通过从根到叶跟踪这个图，你可以使用链式法则自动计算梯度。</p><p>在前向传播中，autograd会同时做两件事：</p><ul><li>运行请求的操作来计算结果tensor，并且</li><li>维持DAG中这个操作的梯度函数。</li></ul><p>当 .backward() 在DAG的根上被调用时，反向传播启动。autograd这时：</p><ul><li>计算每个 .grad_fn 的梯度，</li><li>将他们累加到各自的tensor的 .grad 属性上，并且</li><li>利用链式法则，一直传播到叶子 tensor。</li></ul><p>下面是我们示例中DAG的可视化表示。在图中，箭头是向前通过的方向。节点表示正向传递中每个操作的向后函数。蓝色的叶节点表示叶张量a和b。</p><img src="/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class=""><h1 id="Neural-Networks"><a href="#Neural-Networks" class="headerlink" title="Neural Networks"></a>Neural Networks</h1><p>神经网路可以用 torch.nn 包进行创建。</p><p>现在你已经了解了 autograd，torch.nn 依赖于 autograd 来定义模型并对它们进行微分。一个 nn.module 包含很多层和一个返回输出的方法 forward(input)。</p><p>例如，看看这个分类数字图像的网络：</p><img src="/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" alt="convnet"><p>这是一个简单的前馈网络。它接受输入，一个接一个地将其输入到几个层中，然后最后给出输出。</p><p>神经网路的典型训练步骤如下：</p><ul><li>定义一个具有一些可学习参数(或权值)的神经网络</li><li>迭代输入数据集</li><li>通过网络处理输入</li><li>计算损失(输出距离正确有多远)</li><li>梯度反向传播回网络的参数</li><li>更新网络权重，通常是用一个简单的更新规则：<em>weight &#x3D; weight - learning_rate * gradient</em></li></ul><h2 id="Define-the-network"><a href="#Define-the-network" class="headerlink" title="Define the network"></a>Define the network</h2><p>我们定义这个网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        <span class="hljs-comment"># 1 input image channel, 6 output channels, 5x5 square convolution</span><br>        <span class="hljs-comment"># kernel</span><br>        self.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-comment"># an affine operation: y = Wx + b</span><br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)  <span class="hljs-comment"># 5*5 from image dimension</span><br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># Max pooling over a (2, 2) window</span><br>        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>        <span class="hljs-comment"># If the size is a square, you can specify with a single number</span><br>        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="hljs-number">2</span>)<br>        x = torch.flatten(x, <span class="hljs-number">1</span>) <span class="hljs-comment"># flatten all dimensions except the batch dimension</span><br>        x = F.relu(self.fc1(x))<br>        x = F.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>net = Net()<br><span class="hljs-built_in">print</span>(net)<br></code></pre></td></tr></table></figure><p>你只需要定义正向函数，而反向函数(计算梯度部分)将使用 autograd 自动为你定义。你可以在正向函数中使用任何张量运算。</p><p>模型的可学习参数由 net.parameters() 返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = <span class="hljs-built_in">list</span>(net.parameters())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(params))<br><span class="hljs-built_in">print</span>(params[<span class="hljs-number">0</span>].size())  <span class="hljs-comment"># conv1&#x27;s .weight</span><br></code></pre></td></tr></table></figure><p>我们尝试输入一个随机的 32*32 数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span> = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)<br>out = net(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(out)<br></code></pre></td></tr></table></figure><p>默认的梯度会累加，因此我们通常在backward之前清除掉之前的梯度值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net.zero_grad()<br>out.backward(torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><blockquote><p>注意：torch.nn只支持mini-batches的输入。整个torch.nn包的输入都必须第一维是batch，即使只有一个样本也要弄成batch是1的输入。例如，nn.Conv2d将接收4D Tensor输入：<em>nSamples x nChannels x Height x Width</em>。如果只有一个样本，可以使用 input.unsqueeze(0) 来增加维度。</p></blockquote><h2 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h2><p>损失函数的参数是(output, target)对，output是模型的预测，target是实际的值。损失函数会计算预测值和真实值的差别，损失越小说明预测的越准。</p><p>PyTorch提供了许多不同的<a href="https://pytorch.org/docs/stable/nn.html">损失函数</a>。一个简单的损失函数是：nn.MESLoss，计算输出和目标之间的均方误差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">output = net(<span class="hljs-built_in">input</span>)<br>target = torch.randn(<span class="hljs-number">10</span>)  <span class="hljs-comment"># a dummy target, for example</span><br>target = target.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># make it the same shape as output</span><br>criterion = nn.MSELoss()<br><br>loss = criterion(output, target)<br><span class="hljs-built_in">print</span>(loss)<br></code></pre></td></tr></table></figure><p>如果你使用 .grad_fn 属性，沿着 loss 反向走，你可以看到下面这样的一个计算图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span> -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d<br>      -&gt; flatten -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear<br>      -&gt; MSELoss<br>      -&gt; loss<br></code></pre></td></tr></table></figure><p>因此当调用loss.backward()时，PyTorch会计算这个图中所有requires_grad&#x3D;True的tensor关于loss的梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(loss.grad_fn)  <span class="hljs-comment"># MSELoss</span><br><span class="hljs-built_in">print</span>(loss.grad_fn.next_functions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])  <span class="hljs-comment"># Linear</span><br><span class="hljs-built_in">print</span>(loss.grad_fn.next_functions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].next_functions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])  <span class="hljs-comment"># ReLU</span><br></code></pre></td></tr></table></figure><h2 id="Backpop"><a href="#Backpop" class="headerlink" title="Backpop"></a>Backpop</h2><p>在调用loss.backward()之前，我们需要清除掉tensor里之前的梯度，否则会累加进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">net.zero_grad()     <span class="hljs-comment"># zeroes the gradient buffers of all parameters</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;conv1.bias.grad before backward&#x27;</span>)<br><span class="hljs-built_in">print</span>(net.conv1.bias.grad)<br><br>loss.backward()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;conv1.bias.grad after backward&#x27;</span>)<br><span class="hljs-built_in">print</span>(net.conv1.bias.grad)<br></code></pre></td></tr></table></figure><p>现在，我们已经知道了如何使用损失函数。</p><h2 id="Upadate-the-weights"><a href="#Upadate-the-weights" class="headerlink" title="Upadate the weights"></a>Upadate the weights</h2><p>更新参数最简单的方法是使用随机梯度下降(SGD)：<em>weight &#x3D; weight - learning_rate * gradient</em>。我们可以使用如下简单的代码来实现更新：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">learning_rate = <span class="hljs-number">0.01</span><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> net.parameters():<br>    f.data.sub_(f.grad.data * learning_rate)<br></code></pre></td></tr></table></figure><p>通常我们会使用更加复杂的优化方法，比如SGD, Nesterov-SGD, Adam, RMSProp等等。为了实现这些算法，我们可以使用torch.optim包，它的用法也非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-comment"># create your optimizer</span><br>optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># in your training loop:</span><br>optimizer.zero_grad()   <span class="hljs-comment"># zero the gradient buffers</span><br>output = net(<span class="hljs-built_in">input</span>)<br>loss = criterion(output, target)<br>loss.backward()<br>optimizer.step()    <span class="hljs-comment"># Does the update</span><br></code></pre></td></tr></table></figure><h1 id="Training-a-Classifier"><a href="#Training-a-Classifier" class="headerlink" title="Training a Classifier"></a>Training a Classifier</h1><p>介绍了PyTorch神经网络相关包之后我们就可以用这些知识来构建一个分类器了。</p><h2 id="What-about-data"><a href="#What-about-data" class="headerlink" title="What about data?"></a>What about data?</h2><p>通常，当你必须处理图像，文本，音频或视频数据时，你可以使用标准的python包将数据加载到一个numpy数组。然后再转换成tensor数据。</p><ul><li>对于处理图像，常见的lib包括Pillow和OpenCV</li><li>对于音频，常见的lib包括scipy和librosa</li><li>对于文本，可以使用标准的Python库，另外比较流行的lib包括NLTK和SpaCy</li></ul><p>对于视觉，torchvision被专门创建，它对于常见数据集比如Imagenet, CIFAR10, MNIST等提供了加载的方法。并且它也提供很多数据转化的工具，包括torchvision.datasets和torch.utils.data.DataLoader。这会极大的简化我们的工作，避免重复的代码。</p><p>在这个教程里，我们使用CIFAR10数据集。它包括十个类别：”airplane”, “automobile”, “bird”, “cat”, “deer”, “dog”, “frog”, “horse”, “ship”,”truck”。图像的对象是3x32x32，也就是3通道(RGB)的32x32的图片。下面是一些样例图片。</p><img src="/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" alt="cifar10样例"><h2 id="Training-an-image-classifier"><a href="#Training-an-image-classifier" class="headerlink" title="Training an image classifier"></a>Training an image classifier</h2><p>训练步骤如下：</p><ol><li>使用torchvision加载和预处理CIFAR10训练和测试数据集。</li><li>定义卷积网络</li><li>定义损失函数</li><li>用训练数据训练模型</li><li>用测试数据测试模型</li></ol><h3 id="1-加载并预处理数据"><a href="#1-加载并预处理数据" class="headerlink" title="1. 加载并预处理数据"></a>1. 加载并预处理数据</h3><p>通过使用torchvision，我们可以轻松的加载CIFAR10数据集。首先我们导入相关的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></td></tr></table></figure><p>torchvision读取的datasets是PILImage对象，它的取值范围是[0, 1]，我们把它转换到范围[-1, 1]。</p><blockquote><p>如果在windows上运行得到一个BrokenPipeError错误，尝试将torch.utils.data.DataLoader()的num_worker设置为0</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">transform = transforms.Compose(<br>    [transforms.ToTensor(),<br>     transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>))])<br><br>batch_size = <span class="hljs-number">4</span><br><br>trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>,<br>                                        download=<span class="hljs-literal">True</span>, transform=transform)<br>trainloader = torch.utils.data.DataLoader(trainset, batch_size=batch_size,<br>                                          shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">2</span>)<br><br>testset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>, transform=transform)<br>testloader = torch.utils.data.DataLoader(testset, batch_size=batch_size,<br>                                         shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">2</span>)<br><br>classes = (<span class="hljs-string">&#x27;plane&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>,<br>           <span class="hljs-string">&#x27;deer&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;frog&#x27;</span>, <span class="hljs-string">&#x27;horse&#x27;</span>, <span class="hljs-string">&#x27;ship&#x27;</span>, <span class="hljs-string">&#x27;truck&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们来看几张图片，如下图所示，显示图片的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># functions to show an image</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">imshow</span>(<span class="hljs-params">img</span>):<br>    img = img / <span class="hljs-number">2</span> + <span class="hljs-number">0.5</span>     <span class="hljs-comment"># unnormalize</span><br>    npimg = img.numpy()<br>    plt.imshow(np.transpose(npimg, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)))<br>    plt.show()<br><br><br><span class="hljs-comment"># get some random training images</span><br>dataiter = <span class="hljs-built_in">iter</span>(trainloader)<br>images, labels = dataiter.<span class="hljs-built_in">next</span>()<br><br><span class="hljs-comment"># show images</span><br>imshow(torchvision.utils.make_grid(images))<br><span class="hljs-comment"># print labels</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(batch_size)))<br></code></pre></td></tr></table></figure><h3 id="2-定义卷积神经网路"><a href="#2-定义卷积神经网路" class="headerlink" title="2. 定义卷积神经网路"></a>2. 定义卷积神经网路</h3><p>网络结构和上一节的介绍类似，只是输入通道从1变成3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<br>        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)<br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.pool(F.relu(self.conv1(x)))<br>        x = self.pool(F.relu(self.conv2(x)))<br>        x = torch.flatten(x, <span class="hljs-number">1</span>) <span class="hljs-comment"># flatten all dimensions except batch</span><br>        x = F.relu(self.fc1(x))<br>        x = F.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>net = Net()<br></code></pre></td></tr></table></figure><h3 id="3-定义损失函数和优化器"><a href="#3-定义损失函数和优化器" class="headerlink" title="3. 定义损失函数和优化器"></a>3. 定义损失函数和优化器</h3><p>我们这里使用交叉熵损失函数，Optimizer使用带冲量的SGD。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure><h3 id="4-训练网络"><a href="#4-训练网络" class="headerlink" title="4. 训练网络"></a>4. 训练网络</h3><p>这就是事情开始变得有趣的时候。我们只需遍历数据迭代器，将输入输入提供给网络并进行优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):  <span class="hljs-comment"># loop over the dataset multiple times</span><br><br>    running_loss = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainloader, <span class="hljs-number">0</span>):<br>        <span class="hljs-comment"># get the inputs; data is a list of [inputs, labels]</span><br>        inputs, labels = data<br><br>        <span class="hljs-comment"># zero the parameter gradients</span><br>        optimizer.zero_grad()<br><br>        <span class="hljs-comment"># forward + backward + optimize</span><br>        outputs = net(inputs)<br>        loss = criterion(outputs, labels)<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-comment"># print statistics</span><br>        running_loss += loss.item()<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:    <span class="hljs-comment"># print every 2000 mini-batches</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[<span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>:5d&#125;</span>] loss: <span class="hljs-subst">&#123;running_loss / <span class="hljs-number">2000</span>:<span class="hljs-number">.3</span>f&#125;</span>&#x27;</span>)<br>            running_loss = <span class="hljs-number">0.0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Finished Training&#x27;</span>)<br></code></pre></td></tr></table></figure><p>快速保存模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">PATH = <span class="hljs-string">&#x27;./cifar_net.pth&#x27;</span><br>torch.save(net.state_dict(), PATH)<br></code></pre></td></tr></table></figure><h3 id="5-在测试集上测试网络"><a href="#5-在测试集上测试网络" class="headerlink" title="5. 在测试集上测试网络"></a>5. 在测试集上测试网络</h3><p>我们在训练集上训练两次。使用测试集上的数据进行测试。首先随机抽取几个样本进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dataiter = <span class="hljs-built_in">iter</span>(testloader)<br>images, labels = dataiter.<span class="hljs-built_in">next</span>()<br><br><span class="hljs-comment"># print images</span><br>imshow(torchvision.utils.make_grid(images))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;GroundTruth: &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;classes[labels[j]]:5s&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)))<br></code></pre></td></tr></table></figure><img src="/2022/10/04/PyTorch%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" alt="随机测试"><p>接着，加载刚刚生成的模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = Net()<br>net.load_state_dict(torch.load(PATH))<br></code></pre></td></tr></table></figure><p>使用模型进行预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">outputs = net(images)<br></code></pre></td></tr></table></figure><p>outputs是10个分类的logits。我们在训练的时候需要用softmax把它变成概率(CrossEntropyLoss帮我们做了)，但是预测的时候没有必要，因为我们只需要知道哪个分类的概率大就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">_, predicted = torch.<span class="hljs-built_in">max</span>(outputs, <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Predicted: &#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;classes[predicted[j]]:5s&#125;</span>&#x27;</span><br>                              <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)))<br>                        <br></code></pre></td></tr></table></figure><p>接下来看看模型在整个测试集上的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">correct = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><span class="hljs-comment"># since we&#x27;re not training, we don&#x27;t need to calculate the gradients for our outputs</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, labels = data<br>        <span class="hljs-comment"># calculate outputs by running images through the network</span><br>        outputs = net(images)<br>        <span class="hljs-comment"># the class with the highest energy is what we choose as prediction</span><br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>().item()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Accuracy of the network on the 10000 test images: <span class="hljs-subst">&#123;<span class="hljs-number">100</span> * correct // total&#125;</span> %&#x27;</span>)<br></code></pre></td></tr></table></figure><p>随机预测的成功率大概只有10%，可以发现模型的成功率高于此，说明模型还是学到了东西的。我们也可以看每个分类的准确率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># prepare to count predictions for each class</span><br>correct_pred = &#123;classname: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> classname <span class="hljs-keyword">in</span> classes&#125;<br>total_pred = &#123;classname: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> classname <span class="hljs-keyword">in</span> classes&#125;<br><br><span class="hljs-comment"># again no gradients needed</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, labels = data<br>        outputs = net(images)<br>        _, predictions = torch.<span class="hljs-built_in">max</span>(outputs, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># collect the correct predictions for each class</span><br>        <span class="hljs-keyword">for</span> label, prediction <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(labels, predictions):<br>            <span class="hljs-keyword">if</span> label == prediction:<br>                correct_pred[classes[label]] += <span class="hljs-number">1</span><br>            total_pred[classes[label]] += <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># print accuracy for each class</span><br><span class="hljs-keyword">for</span> classname, correct_count <span class="hljs-keyword">in</span> correct_pred.items():<br>    accuracy = <span class="hljs-number">100</span> * <span class="hljs-built_in">float</span>(correct_count) / total_pred[classname]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Accuracy for class: <span class="hljs-subst">&#123;classname:5s&#125;</span> is <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.1</span>f&#125;</span> %&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Training-on-GPU"><a href="#Training-on-GPU" class="headerlink" title="Training on GPU"></a>Training on GPU</h2><p>为了在GPU上训练，我们需要把Tensor移到GPU上。首先我们看看是否有GPU，如果没有，那么我们只能是CPU。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&#x27;cuda:0&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><span class="hljs-comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span><br><br><span class="hljs-built_in">print</span>(device)<br></code></pre></td></tr></table></figure><p>假设我们有GPU，我们需要把网络以及每一步产生的数据都发给GPU:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net.to(device)<br>inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<br></code></pre></td></tr></table></figure><blockquote><p>为什么GPU与CPU相比没有巨大的加速?因为神经网路很小。</p></blockquote><h2 id="Training-on-multiple-GPUs"><a href="#Training-on-multiple-GPUs" class="headerlink" title="Training on multiple GPUs"></a>Training on multiple GPUs</h2><p><a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html">数据并行</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>PyTorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>urdf学习笔记</title>
    <link href="/2022/09/30/urdf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/30/urdf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="URDF简介"><a href="#URDF简介" class="headerlink" title="URDF简介"></a>URDF简介</h1><p>URDF(Unified Robot Description Format)，统一机器人描述格式，是一种特殊的xml格式，用来描述一个机器人。urdf功能包包含一个urdf格式文件的C++解析器，这样，任何通过统一编码格式设计的机器人都可以通过该解析器得到一个可视化的模型。</p><p>在ROS中，常常有以xxx_description命名的包，这些包中包含的文件就是某个机器人的描述文件，如著名的turtlebot_description等。</p><p>URDF的形成通常有三种途径：</p><ol><li>直接使用URDF的XML tag进行文件编写。</li><li>使用XACRO建模后转为URDF文件。Xacro (XML Macros) 是一种XML宏语言，可以简化URDF文件，更少的代码实现同样的描述。</li><li>使用SolidWorks进行三维建图后使用SW2URDF插件转换为URDF文件。</li></ol><h1 id="URDF文件元素和参数"><a href="#URDF文件元素和参数" class="headerlink" title="URDF文件元素和参数"></a>URDF文件元素和参数</h1><img src="/2022/09/30/urdf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class=""><h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;macroed&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://ros.org/wiki/xacro&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;H_b&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.04&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;H_0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;H_1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.05&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;R_0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.02&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PI&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3.1415&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;L_2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.2&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base_link&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">box</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;0.14 0.11 $&#123;H_b&#125;&#x27;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;joint_0&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;fixed&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 $&#123;H_b/2+H_0/2&#125;&#x27;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;base_link&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;link_0&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;link_0&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;oring xyz=&#x27;0 0 $&#123;-(H_b/2+H_0/2)&#125;&#x27; rpy=&#x27;0 0 0&#x27; /&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cylinder</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&#x27;$&#123;R_0&#125;&#x27;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&#x27;$&#123;H_0&#125;&#x27;</span>  /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;joint_1&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;revolute&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">limit</span> <span class="hljs-attr">effort</span>=<span class="hljs-string">&#x27;300&#x27;</span> <span class="hljs-attr">velocity</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">lower</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">upper</span>=<span class="hljs-string">&#x27;$&#123;PI&#125;&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 $&#123;H_0/2+H_1/2&#125;&#x27;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;link_0&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;link_1&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 1&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;link_1&#x27;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">box</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;0.08 0.08 $&#123;H_1&#125;&#x27;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;joint_2&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;revolute&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">limit</span> <span class="hljs-attr">effort</span>=<span class="hljs-string">&#x27;300&#x27;</span> <span class="hljs-attr">velocity</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-attr">lower</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">upper</span>=<span class="hljs-string">&#x27;$&#123;PI&#125;&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&#x27;$&#123;PI/2&#125; 0 0&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;link_1&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&#x27;link_2&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;0 0 1&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;link_2&#x27;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&#x27;$&#123;L_2/2&#125; 0 0&#x27;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&#x27;0 0 0&#x27;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">box</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;$&#123;L_2&#125; 0.05 0.03&#x27;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示如下：</p><img src="/2022/09/30/urdf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class=""><h1 id="urdf文件的检查"><a href="#urdf文件的检查" class="headerlink" title="urdf文件的检查"></a>urdf文件的检查</h1><p>可以用如下命令检查urdf文件的合法性，需要到urdf文件所在文件夹下运行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">check_urdf</span> my_robot.urdf<br></code></pre></td></tr></table></figure><p>对于扩展的xacro文件，用以下命令：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">check_urdf &lt; <span class="hljs-comment">(xacro my_robot.urdf.xacro)</span><br></code></pre></td></tr></table></figure><h1 id="urdf文件的显示"><a href="#urdf文件的显示" class="headerlink" title="urdf文件的显示"></a>urdf文件的显示</h1><h2 id="终端中使用命令显示："><a href="#终端中使用命令显示：" class="headerlink" title="终端中使用命令显示："></a>终端中使用命令显示：</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">roslaunch urdf_tutorial <span class="hljs-keyword">display</span>.launch <span class="hljs-keyword">model</span>:=<span class="hljs-string">&#x27;$(find arm_description)/urdf/my_robot.urdf.xacro&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="使用launch文件显示"><a href="#使用launch文件显示" class="headerlink" title="使用launch文件显示"></a>使用launch文件显示</h2><p>编写display.launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;model&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;$(find arm_description)/urdf/my_robot.urdf.xacro&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gui&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rvizconfig&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;$(find urdf_tutorial)/rviz/urdf.rviz&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_description&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;$(find xacro)/xacro $(arg model)&quot;</span> /&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;use_gui&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$(arg gui)&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">if</span>=<span class="hljs-string">&quot;$(arg gui)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">unless</span>=<span class="hljs-string">&quot;$(arg gui)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;-d $(arg rvizconfig)&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://wiki.ros.org/urdf/Tutorials">http://wiki.ros.org/urdf/Tutorials</a></li><li><a href="https://blog.csdn.net/shenyan0712/article/details/89919959">ROS中URDF格式和使用</a></li><li><a href="https://www.guyuehome.com/33988">ROS机器人描述——URDF，SRDF和XACRO</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tf学习笔记</title>
    <link href="/2022/09/29/tf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/29/tf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为tf2是tf的超集，且tf即将被废弃。所以可以直接学习tf2。</p></blockquote><h1 id="tf简介"><a href="#tf简介" class="headerlink" title="tf简介"></a>tf简介</h1><p>在机器人控制中，坐标转换是非常重要的，在ROS中使用tf软件包进行坐标转换。<a href="#%E5%8F%82%E8%80%83">参考1</a>是官方教程文档。</p><p>一个机器人系统中通常有很多三维坐标系，而且一般会随着时间变化。tf就是以时间为轴，跟踪者这些坐标系（frame），默认可以记录10s内的坐标系变化。使用tf包，我们可以得知以下问题的答案：</p><ul><li>五秒钟之前，机器人头参考系相对于全局参考系的关系是什么样的？</li><li>机器人夹取的物体相对于机器人中心参考系的位置在哪里？</li><li>机器人中心参考系相对于全局参考系的位置在哪里？</li></ul><p>坐标转换包TF是一个让用户可以实时跟踪多个参考系的功能包，它使用的是树型数据结构，可以根据时间缓冲实时维护多个参考系之间的坐标变换关系。从而得知一个点在多个坐标系中的坐标表示。</p><p>tf坐标系三个轴分别有三种颜色，其中红色为x轴，绿色为y轴，蓝色为z轴。</p><h1 id="tf工具"><a href="#tf工具" class="headerlink" title="tf工具"></a>tf工具</h1><p>查看当前tf树中所有坐标系的发布状态：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun tf tf_monitor</span><br></code></pre></td></tr></table></figure><p>查看当前所有坐标之间的变换关系，可通过刷新更新当前树的内容:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun rqt_tf_tree rqt_tf_tree</span><br></code></pre></td></tr></table></figure><p>获取reference_frame和target_frame之间的坐标变换关系:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">rosrun tf tf_echo <span class="hljs-selector-attr">[reference_frame]</span> <span class="hljs-selector-attr">[target_frame]</span><br></code></pre></td></tr></table></figure><p>使用rviz可视化坐标系：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosrun rviz rviz</span><br></code></pre></td></tr></table></figure><p>先在”Global Options”下设置Fixed Frame，然后点击ADD,加入TF display。</p><h1 id="tf的使用"><a href="#tf的使用" class="headerlink" title="tf的使用"></a>tf的使用</h1><p>使用tf功能包，总的来说需要两个步骤：</p><ol><li><strong>广播tf变换</strong>：向系统中广播参考系之间的坐标变换关系，系统中更可能会存在多个不同部分的tf变换广播，每个广播都可以直接将参考系变换关系直接插入tf树中，不需要再进行同步。</li><li><strong>监听tf变换</strong>： 接收并缓存系统中发布的所有参考系变换，并从中查询所需要的参考系变换。</li></ol><h2 id="广播tf"><a href="#广播tf" class="headerlink" title="广播tf"></a>广播tf</h2><p>本质上就是发布我们建立的坐标系。广播的坐标系变换可能是不变的，也可能是随着时间变化的。</p><h3 id="静态tf广播"><a href="#静态tf广播" class="headerlink" title="静态tf广播"></a>静态tf广播</h3><p>静态的坐标系变换意味着两个坐标系之间的相对位置不会发生变化，他们有一个固定的变换关系。静态广播tf有两种发布方式，一种是使用代码，另一种是使用static_transform_publisher发布。具体的教程见：<br><a href="http://wiki.ros.org/tf2/Tutorials/Writing%20a%20tf2%20static%20broadcaster%20%28C%2B%2B%29">Writing a tf2 static broadcaster (C++)</a>。<br>其中后者既可以使用命令行发布，也可以使用launch文件启动发布。我认为使用后者方便又简单。这里给出后者的使用说明。</p><p>命令行使用方式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># RPY形式发布</span><br>rosrun tf2_ros static_transform_publisher <span class="hljs-keyword">x</span> <span class="hljs-keyword">y</span> z yaw pitch roll frame_id child_frame_id<br><br><span class="hljs-comment"># 四元数形式发布</span><br>rosrun tf2_ros static_transform_publisher <span class="hljs-keyword">x</span> <span class="hljs-keyword">y</span> z <span class="hljs-keyword">qx</span> qy qz <span class="hljs-keyword">qw</span> frame_id child_frame_id<br></code></pre></td></tr></table></figure><p>launch文件发布：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;launch&gt;<br>&lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;tf2_ros&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;static_transform_publisher&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;link1_broadcaster&quot;</span> args<span class="hljs-operator">=</span><span class="hljs-string">&quot;1 0 0 0 0 0 1 link1_parent link1&quot;</span> /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><h3 id="动态tf广播"><a href="#动态tf广播" class="headerlink" title="动态tf广播"></a>动态tf广播</h3><p>动态tf广播意味着两个坐标系之间的转换关系一直在发生变化，虽然tf tree中可能也有其他的变换关系，但他们之间并不影响。这种动态的变换可能是因为实时订阅其他的消息而改变（<a href="http://wiki.ros.org/tf2/Tutorials/Writing%20a%20tf2%20broadcaster%20%28C%2B%2B%29">官网例子</a>），也有可能是随着时间改变。这里给出一个后者的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf2_ros/transform_broadcaster.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf2/LinearMath/Quaternion.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf2_broadcaster&quot;</span>);<br>  ros::NodeHandle node;<br><br>  tf2_ros::TransformBroadcaster tfb;<br>  geometry_msgs::TransformStamped transformStamped;<br><br>  <br>  transformStamped.header.frame_id = <span class="hljs-string">&quot;frame1&quot;</span>;<br>  transformStamped.child_frame_id = <span class="hljs-string">&quot;frame2&quot;</span>;<br><span class="hljs-comment">//   transformStamped.transform.translation.x = 0.0;</span><br><span class="hljs-comment">//   transformStamped.transform.translation.y = 2.0;</span><br>  <br>  transformStamped.transform.translation.z = <span class="hljs-number">0.0</span>;<br>  tf2::Quaternion q;<br>        q.<span class="hljs-built_in">setRPY</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  transformStamped.transform.rotation.x = q.<span class="hljs-built_in">x</span>();<br>  transformStamped.transform.rotation.y = q.<span class="hljs-built_in">y</span>();<br>  transformStamped.transform.rotation.z = q.<span class="hljs-built_in">z</span>();<br>  transformStamped.transform.rotation.w = q.<span class="hljs-built_in">w</span>();<br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())&#123;<br>    transformStamped.header.stamp = ros::Time::<span class="hljs-built_in">now</span>(); <br>    transformStamped.transform.translation.x = <span class="hljs-number">2.0</span>*<span class="hljs-built_in">sin</span>(ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toSec</span>());<br>    transformStamped.transform.translation.y = <span class="hljs-number">2.0</span>*<span class="hljs-built_in">cos</span>(ros::Time::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">toSec</span>());<br><br>    tfb.<span class="hljs-built_in">sendTransform</span>(transformStamped);<br>    rate.<span class="hljs-built_in">sleep</span>();<br>    <span class="hljs-comment">// printf(&quot;sending\n&quot;);</span><br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="监听tf"><a href="#监听tf" class="headerlink" title="监听tf"></a>监听tf</h2><p>监听的目的是得到两个坐标系之间的转换关系，包括平移和旋转，从而进行其他任务，例如将一个点从一个坐标系下转到另一个坐标系下表示。<br>首先我们发布了一个静态tf广播：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rosrun</span> tf2_ros static_transform_publisher <span class="hljs-number">0</span>.<span class="hljs-number">1</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> base_link base_laser<br></code></pre></td></tr></table></figure><p>然后使用下面的代码监听tf，下面示例代码的作用获得base_link到base_laser的转换关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ros/ros.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;geometry_msgs/PointStamped.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tf2_ros/transform_listener.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>  ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;my_tf_listener&quot;</span>);<br>  ros::NodeHandle node;<br><br>  tf2_ros::Buffer tfBuffer;<br>  <span class="hljs-function">tf2_ros::TransformListener <span class="hljs-title">tfListener</span><span class="hljs-params">(tfBuffer)</span></span>;<br><br>  <span class="hljs-function">ros::Rate <span class="hljs-title">rate</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;<br>  <span class="hljs-keyword">while</span> (node.<span class="hljs-built_in">ok</span>())&#123;<br>    geometry_msgs::TransformStamped transformStamped;<br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-comment">// 查询监听器进行特定的转换,从/base_laser坐标系开始变换到/base_link坐标系;</span><br>      <span class="hljs-comment">// ros::Time(0)会给出最近的可用的变换</span><br>      transformStamped  = tfBuffer.<span class="hljs-built_in">lookupTransform</span>(<span class="hljs-string">&quot;base_laser&quot;</span>, <span class="hljs-string">&quot;base_link&quot;</span>,  <br>                               ros::<span class="hljs-built_in">Time</span>(<span class="hljs-number">0</span>));<br><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (tf2::TransformException ex)&#123;<br>      <span class="hljs-built_in">ROS_ERROR</span>(<span class="hljs-string">&quot;%s&quot;</span>,ex.<span class="hljs-built_in">what</span>());<br>      ros::<span class="hljs-built_in">Duration</span>(<span class="hljs-number">1.0</span>).<span class="hljs-built_in">sleep</span>();<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;pos:(%.2f, %.2f, %.2f)&quot;</span>, transformStamped.transform.translation.x, transformStamped.transform.translation.y, transformStamped.transform.translation.z);<br>    <span class="hljs-comment">// ROS_INFO(&quot;偏航角:(%.2f, %.2f, %.2f)&quot;, transform.getOrigin().x(), transform.getOrigin().y(), transform.getOrigin().z());</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;quaternion:(%.2f, %.2f, %.2f, %.2f)&quot;</span>, transformStamped.transform.rotation.x, transformStamped.transform.rotation.y, transformStamped.transform.rotation.z, transformStamped.transform.rotation.w);<br>    <br><br><br>    <br>    rate.<span class="hljs-built_in">sleep</span>();<br>  &#125;<br>  ros::<span class="hljs-built_in">spin</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://wiki.ros.org/tf2/Tutorials">http://wiki.ros.org/tf2/Tutorials</a></li><li><a href="https://blog.csdn.net/Kalenee/article/details/107593033">ROS学习——tf2</a></li><li><a href="http://docs.ros.org/en/jade/api/tf2/html/index.html">tf2——API</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS实用技巧</title>
    <link href="/2022/09/29/ROS%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/09/29/ROS%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="只编译某个功能包"><a href="#只编译某个功能包" class="headerlink" title="只编译某个功能包"></a>只编译某个功能包</h1><p>一个工作空间下可能有很多功能包吗，每次都用catkin_make编译所有包，效率将很低下。如果只是修改了某个包，可以只编译这个包就行，命令如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 注意妙用TAB键</span><br><span class="hljs-attribute">catkin_make</span> -DCATKIN_WHITELIST_PACKAGES=<span class="hljs-string">&quot;你的包名&quot;</span><br></code></pre></td></tr></table></figure><p>编译某几个包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">catkin_make -DCATKIN_WHITELIST_PACKAGES<span class="hljs-operator">=</span><span class="hljs-string">&quot;包1;包2&quot;</span><br></code></pre></td></tr></table></figure><h1 id="ROS功能包的常用开发流程"><a href="#ROS功能包的常用开发流程" class="headerlink" title="ROS功能包的常用开发流程"></a>ROS功能包的常用开发流程</h1><p>在工作空间中创建一个功能包,后面是常用依赖:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">catkin_create_pkg mypkg roscpp rospy sensor_msgs std_msgs</span><br></code></pre></td></tr></table></figure><p>在mypkg&#x2F;src文件夹下编写自己的c++代码（mynode.cpp），头文件卸载mypkg&#x2F;include文件夹下。一般情况下，一个c++文件就是一个节点。</p><p>修改CMakeList.txt文件，加入以下命令：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">mynode</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">mynode</span>.<span class="hljs-params">cpp</span>)</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">mynode</span> $&#123;<span class="hljs-params">catkin_LIBRARIES</span>&#125;)</span><br></code></pre></td></tr></table></figure><p>对于python文件，建议创建一个新的文件夹,如scripts&#x2F;存放python文件。</p><p>python文件需要给予可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 你的python文件<br></code></pre></td></tr></table></figure><p>最后，可以使用launch文件启动，也可以使用rosrun启动节点。</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器常用命令</title>
    <link href="/2022/09/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/27/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h1><ol><li><a href="https://www.runoob.com/linux/linux-command-manual.html">菜鸟教程Linux命令大全</a></li></ol><h1 id="常用指令（持续总结）"><a href="#常用指令（持续总结）" class="headerlink" title="常用指令（持续总结）"></a>常用指令（持续总结）</h1><table><thead><tr><th align="center">操作</th><th align="center">具体操作命令</th><th align="center">详细介绍</th></tr></thead><tbody><tr><td align="center">进入指定目录</td><td align="center"><font color=red> cd 目录路径 </font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-cd.html">Linux cd命令</a></td></tr><tr><td align="center">创建一个文件夹</td><td align="center"><font color=red>mkdir 文件夹名称</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-mkdir.html">Linux mkdir 命令</a></td></tr><tr><td align="center">查看当前路径</td><td align="center"><font color=red>pwd</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-pwd.html">Linux pwd命令</a></td></tr><tr><td align="center">查看当前目录</td><td align="center"><font color=red>ls</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-ls.html">Linux ls 命令</a></td></tr><tr><td align="center">复制文件</td><td align="center"><font color=red>cp 文件 目的地址</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-cp.html">Linux cp 命令</a></td></tr><tr><td align="center">复制文件夹</td><td align="center"><font color=red>cp -r 文件夹&#x2F; 目的地址</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-cp.html">Linux cp 命令</a></td></tr><tr><td align="center">移动文件</td><td align="center"><font color=red>mv 文件 目的地址</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-mv.html">Linux mv 命令</a></td></tr><tr><td align="center">删除文件</td><td align="center"><font color=red>rm -f 文件</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-rm.html">Linux rm 命令</a></td></tr><tr><td align="center">删除文件夹</td><td align="center"><font color=red>rm -rf 文件夹</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-rm.html">Linux rm 命令</a></td></tr><tr><td align="center">从网站下载文件</td><td align="center"><font color=red>wget 文件链接地址</font></td><td align="center"><a href="https://www.cnblogs.com/wuheng1991/p/5332764.html">Linux wget 命令</a></td></tr><tr><td align="center">解压.tar.gz文件</td><td align="center"><font color=red>tar -zxvf 压缩文件</font></td><td align="center"><a href="https://www.runoob.com/linux/linux-comm-tar.html">Linux tar 命令</a></td></tr></tbody></table><h1 id="conda命令"><a href="#conda命令" class="headerlink" title="conda命令"></a>conda命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装</span><br>bash Anaconda3-2019.07-Linux-x86_64.sh <span class="hljs-comment">#Linux下安装Anaconda</span><br><br><span class="hljs-comment">#常用命令</span><br>conda update -n base conda        <span class="hljs-comment">#update最新版本的conda</span><br>conda update --all                <span class="hljs-comment">#update最新版本的conda</span><br>conda create -n xxxx python=3.5   <span class="hljs-comment">#创建python3.5的xxxx虚拟环境</span><br>conda remove -n xxxx --all        <span class="hljs-comment">#删除xxxx虚拟环境</span><br>conda activate xxxx               <span class="hljs-comment">#开启xxxx环境</span><br>conda deactivate                  <span class="hljs-comment">#关闭环境</span><br>conda <span class="hljs-built_in">env</span> list                    <span class="hljs-comment">#显示所有的虚拟环境</span><br>conda info --envs                 <span class="hljs-comment">#显示所有的虚拟环境</span><br><br><span class="hljs-comment">#更新卸载安装包</span><br>conda list         <span class="hljs-comment">#查看已经安装的文件包</span><br>conda list  -n xxx       <span class="hljs-comment">#指定查看xxx虚拟环境下安装的package</span><br>conda update xxx   <span class="hljs-comment">#更新xxx文件包</span><br>conda uninstall xxx   <span class="hljs-comment">#卸载xxx文件包</span><br><br><span class="hljs-comment">#数据源管理</span><br><span class="hljs-comment">#显示目前conda的数据源有哪些</span><br>conda config --show channels<br><span class="hljs-comment">#添加数据源：例如, 添加清华anaconda镜像：</span><br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br><span class="hljs-comment">#删除数据源</span><br>conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br><br><span class="hljs-comment">#pip安装包管理</span><br>pip list <span class="hljs-comment">#列出当前缓存的包</span><br>pip purge <span class="hljs-comment">#清除缓存</span><br>pip remove <span class="hljs-comment">#删除对应的缓存</span><br>pip <span class="hljs-built_in">help</span> <span class="hljs-comment">#帮助</span><br>pip install xxx <span class="hljs-comment">#安装xxx包</span><br>pip install xxx.whl <span class="hljs-comment">#安装xxx.whl本地包</span><br>pip uninstall xxx <span class="hljs-comment">#删除xxx包</span><br>pip show xxx <span class="hljs-comment">#展示指定的已安装的xxx包</span><br>pip check xxx <span class="hljs-comment">#检查xxx包的依赖是否合适</span><br><br><br></code></pre></td></tr></table></figure><h1 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h1><p><a href="https://www.xshell.com/zh/xshell/">XSHELL和XFTP</a>：免费版足够使用。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy学习--如何进行矩阵操作</title>
    <link href="/2022/09/24/numpy%E5%AD%A6%E4%B9%A0-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/09/24/numpy%E5%AD%A6%E4%B9%A0-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>NumPy是一个开源Python库，几乎在科学和工程中的每个领域都使用它。Numpy包含多维数据结构和矩阵数据结构，并提供了对其进行有效操作的方法。本文将详细介绍数据与矩阵操作的方法。</p><p>NumPy提供了一个N维数据类型：<strong>numpy.ndarray</strong>，它是NumPy中最基础的数据类型。我们可以对numpy.ndarray进行子类化。NumPy官方提供了一些标准数组子类，其中就有矩阵对象：<strong>numpy.matrix</strong>。所以，很明显numpy.matrix是numpy.ndarray的子类。</p><p>numpy.matrix和numpy.ndarray都可以使用进行矩阵操作。其中numpy.matrix语法与MATLAB有些相似，进行矩阵操作更细致化。但奇怪的是官方并不推荐使用numpy.matrix，因为它使得编写一致处理矩阵和规则数组的函数变得非常困难，将来会删除matrix子类。</p><p>本文将介绍两种数据类型进行矩阵操作的方法。</p><h1 id="numpy-matrix类型相关操作"><a href="#numpy-matrix类型相关操作" class="headerlink" title="numpy.matrix类型相关操作"></a>numpy.matrix类型相关操作</h1><h2 id="1-创建矩阵"><a href="#1-创建矩阵" class="headerlink" title="1. 创建矩阵"></a>1. 创建矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>&gt;&gt;&gt;m= np.mat([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])  <span class="hljs-comment">#创建矩阵</span><br>&gt;&gt;&gt;m<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])<br>&gt;&gt;&gt;m= np.matrix([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])  <span class="hljs-comment"># 创建矩阵</span><br>&gt;&gt;&gt;m<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])<br>&gt;&gt;&gt;np.shape(m)          <span class="hljs-comment"># 查看矩阵大小</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>&gt;&gt;&gt;m.shape            <span class="hljs-comment"># 也可以这样</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>&gt;&gt;&gt;m.shape[<span class="hljs-number">0</span>]          <span class="hljs-comment"># 查看矩阵行数</span><br><span class="hljs-number">1</span><br>&gt;&gt;&gt;m.shape[<span class="hljs-number">1</span>]          <span class="hljs-comment"># 查看矩阵列数</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>np.mat()和np.matrix()几乎等价。前者是一个函数，可以将不同数据类型的数据转换成numpy.matrix类型；后者则是numpy.matrix类的构造函数。二者其他区别详见：<a href="http://t.csdn.cn/M2LVg">http://t.csdn.cn/M2LVg</a></p></blockquote><h2 id="2-创建常见的矩阵"><a href="#2-创建常见的矩阵" class="headerlink" title="2. 创建常见的矩阵"></a>2. 创建常见的矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;data1=np.mat(np.zeros((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))    <span class="hljs-comment">#创建一个3*3的零矩阵，矩阵这里zeros函数的参数是一个tuple类型(3,3)</span><br>&gt;&gt;&gt;data1<br>matrix([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>]])<br>&gt;&gt;&gt;data2=np.mat(np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))) <span class="hljs-comment">#创建一个2*4的1矩阵，默认是浮点型的数据，如果需要时int类型，可以使用dtype=int</span><br>&gt;&gt;&gt;data2<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>]])<br>&gt;&gt;&gt;data3=np.mat(np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) <span class="hljs-comment">#这里的random模块使用的是numpy中的random模块，random.rand(2,2)创建的是一个二维数组，需要将其转换成#matrix</span><br>&gt;&gt;&gt;data3<br>matrix([[ <span class="hljs-number">0.57341802</span>,  <span class="hljs-number">0.51016034</span>],<br>        [ <span class="hljs-number">0.56438599</span>,  <span class="hljs-number">0.70515605</span>]])<br>&gt;&gt;&gt;data4=np.mat(np.random.randint(<span class="hljs-number">10</span>,size=(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))) <span class="hljs-comment">#生成一个3*3的0-10之间的随机整数矩阵，如果需要指定下界则可以多加一个参数</span><br>&gt;&gt;&gt;data4<br>matrix([[<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>        [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],<br>        [<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>]])<br>&gt;&gt;&gt;data5=np.mat(np.random.randint(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,size=(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>))) <span class="hljs-comment">#产生一个2-8之间的随机整数矩阵</span><br>&gt;&gt;&gt;data5<br>matrix([[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>],<br>        [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;data6=np.mat(np.eye(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,dtype=<span class="hljs-built_in">int</span>)) <span class="hljs-comment">#产生一个2*2的对角矩阵</span><br>&gt;&gt;&gt;data6<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]])<br> <br>&gt;&gt;&gt;a1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&gt;&gt;&gt;a2=np.mat(np.diag(a1)) <span class="hljs-comment">#生成一个对角线为1、2、3的对角矩阵</span><br>&gt;&gt;&gt;a2<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>]])<br></code></pre></td></tr></table></figure><h2 id="3-矩阵索引"><a href="#3-矩阵索引" class="headerlink" title="3. 矩阵索引"></a>3. 矩阵索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;m=np.mat([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;m[<span class="hljs-number">1</span>:]                    <span class="hljs-comment">#取得第一行的所有元素</span><br>matrix([[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]               <span class="hljs-comment">#第一行第0-1个元素，注意左闭右开,返回的是矩阵</span><br>matrix([[<span class="hljs-number">2</span>]])<br>&gt;&gt;&gt;m[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br>matrix([[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;m[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]                  <span class="hljs-comment">#第一行第2个元素，返回的是数值</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="4-矩阵相乘"><a href="#4-矩阵相乘" class="headerlink" title="4. 矩阵相乘"></a>4. 矩阵相乘</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])      <br>&gt;&gt;&gt;a2=np.mat([[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>]])<br>&gt;&gt;&gt;a3=a1*a2      <span class="hljs-comment">#1*2的矩阵乘以2*1的矩阵，得到1*1的矩阵</span><br>&gt;&gt;&gt;a3<br>matrix([[<span class="hljs-number">5</span>]])<br></code></pre></td></tr></table></figure><h2 id="5-矩阵点乘"><a href="#5-矩阵点乘" class="headerlink" title="5. 矩阵点乘"></a>5. 矩阵点乘</h2><p>对应元素相乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])<br>&gt;&gt;&gt;a2=np.mat([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br>&gt;&gt;&gt;a3=np.multiply(a1,a2)<br>&gt;&gt;&gt;a3<br>matrix([[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><p>矩阵点乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br>&gt;&gt;&gt;a2=a1*<span class="hljs-number">2</span><br>&gt;&gt;&gt;a2<br>matrix([[<span class="hljs-number">4</span>, <span class="hljs-number">4</span>]])<br></code></pre></td></tr></table></figure><h2 id="6-矩阵求逆"><a href="#6-矩阵求逆" class="headerlink" title="6. 矩阵求逆"></a>6. 矩阵求逆</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat(np.eye(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)*<span class="hljs-number">0.5</span>)<br>&gt;&gt;&gt;a1<br>matrix([[ <span class="hljs-number">0.5</span>,  <span class="hljs-number">0.</span> ],<br>        [ <span class="hljs-number">0.</span> ,  <span class="hljs-number">0.5</span>]])<br>&gt;&gt;&gt;a2=a1.I     <span class="hljs-comment">#求矩阵matrix([[0.5,0],[0,0.5]])的逆矩阵</span><br>&gt;&gt;&gt;a2<br>matrix([[ <span class="hljs-number">2.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">2.</span>]])<br></code></pre></td></tr></table></figure><h2 id="7-矩阵转置"><a href="#7-矩阵转置" class="headerlink" title="7. 矩阵转置"></a>7. 矩阵转置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]])<br>&gt;&gt;&gt;a1<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]])<br>&gt;&gt;&gt;a2=a1.T<br>&gt;&gt;&gt;a2<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br></code></pre></td></tr></table></figure><h2 id="8-矩阵分割"><a href="#8-矩阵分割" class="headerlink" title="8. 矩阵分割"></a>8. 矩阵分割</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a=np.mat(ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)))<br>&gt;&gt;&gt;a<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>]])<br>&gt;&gt;&gt;b=a[<span class="hljs-number">1</span>:,<span class="hljs-number">1</span>:]  <span class="hljs-comment">#分割出第二行以后的行和第二列以后的列的所有元素</span><br>&gt;&gt;&gt;b<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>]])<br></code></pre></td></tr></table></figure><h2 id="9-矩阵合并"><a href="#9-矩阵合并" class="headerlink" title="9. 矩阵合并"></a>9. 矩阵合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a=np.mat(np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br>&gt;&gt;&gt;a<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>]])<br>&gt;&gt;&gt;b=np.mat(np.eye(<span class="hljs-number">2</span>))<br>&gt;&gt;&gt;b<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>]])<br>&gt;&gt;&gt;c=np.vstack((a,b))  <span class="hljs-comment">#按列合并，即增加行数</span><br>&gt;&gt;&gt;c<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>]])<br>&gt;&gt;&gt;d=np.hstack((a,b))  <span class="hljs-comment">#按行合并，即行数不变，扩展列数</span><br>&gt;&gt;&gt;d<br>matrix([[ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>],<br>        [ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>]])<br></code></pre></td></tr></table></figure><h2 id="10-计算每一列、行的和"><a href="#10-计算每一列、行的和" class="headerlink" title="10. 计算每一列、行的和"></a>10. 计算每一列、行的和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=np.mat([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]])<br>&gt;&gt;&gt;a1<br>matrix([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>        [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>]])<br>&gt;&gt;&gt;a2=a1.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>) <span class="hljs-comment">#列和，这里得到的是1*2的矩阵</span><br>&gt;&gt;&gt;a2<br>matrix([[<span class="hljs-number">7</span>, <span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;a3=a1.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) <span class="hljs-comment">#行和，这里得到的是3*1的矩阵</span><br>&gt;&gt;&gt;a3<br>matrix([[<span class="hljs-number">2</span>],<br>        [<span class="hljs-number">5</span>],<br>        [<span class="hljs-number">6</span>]])<br>&gt;&gt;&gt;a4=a1[<span class="hljs-number">1</span>,:].<span class="hljs-built_in">sum</span>()  <span class="hljs-comment">#计算第一行所有列的和，这里得到的是一个数值</span><br>&gt;&gt;&gt;a4<br><span class="hljs-number">5</span>                    <span class="hljs-comment">#第0行：1+1；第2行：2+3；第3行：4+2</span><br></code></pre></td></tr></table></figure><h2 id="11-计算最大、最小值和索引"><a href="#11-计算最大、最小值和索引" class="headerlink" title="11. 计算最大、最小值和索引"></a>11. 计算最大、最小值和索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1.<span class="hljs-built_in">max</span>()   <span class="hljs-comment">#计算a1矩阵中所有元素的最大值,这里得到的结果是一个数值</span><br><span class="hljs-number">4</span><br>&gt;&gt;&gt;a2=<span class="hljs-built_in">max</span>(a1[:,<span class="hljs-number">1</span>]) <span class="hljs-comment">#计算第二列的最大值，这里得到的是一个1*1的矩阵</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a2<br>matrix([[<span class="hljs-number">3</span>]])<br>&gt;&gt;&gt;a1[<span class="hljs-number">1</span>,:].<span class="hljs-built_in">max</span>()  <span class="hljs-comment">#计算第二行的最大值，这里得到的是一个一个数值</span><br><span class="hljs-number">3</span><br>&gt;&gt;&gt;np.<span class="hljs-built_in">max</span>(a1,<span class="hljs-number">0</span>)  <span class="hljs-comment">#计算所有列的最大值，这里使用的是numpy中的max函数</span><br>matrix([[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>]])<br>&gt;&gt;&gt;np.<span class="hljs-built_in">max</span>(a1,<span class="hljs-number">1</span>)  <span class="hljs-comment">#计算所有行的最大值，这里得到是一个矩阵</span><br>matrix([[<span class="hljs-number">1</span>],<br>        [<span class="hljs-number">3</span>],<br>        [<span class="hljs-number">4</span>]])<br>&gt;&gt;&gt;np.argmax(a1,<span class="hljs-number">0</span>)    <span class="hljs-comment">#计算所有列的最大值对应在该列中的索引</span><br>matrix([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<br>&gt;&gt;&gt;np.argmax(a1[<span class="hljs-number">1</span>,:])  <span class="hljs-comment">#计算第二行中最大值对应在该行的索引</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="12-矩阵、列表、数组的转换"><a href="#12-矩阵、列表、数组的转换" class="headerlink" title="12. 矩阵、列表、数组的转换"></a>12. 矩阵、列表、数组的转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a1=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]]  <span class="hljs-comment">#列表</span><br>&gt;&gt;&gt;<span class="hljs-built_in">type</span>(a1)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br>&gt;&gt;&gt;a2=np.array(a1)  <span class="hljs-comment">#将列表转换成二维数组</span><br>&gt;&gt;&gt;<span class="hljs-built_in">type</span>(a2)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;<br>&gt;&gt;&gt;a3=np.mat(a1)    <span class="hljs-comment">#将列表转化成矩阵</span><br>&gt;&gt;&gt;<span class="hljs-built_in">type</span>(a3)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.matrix&#x27;</span>&gt;<br>&gt;&gt;&gt;a4=np.array(a3)  <span class="hljs-comment">#将矩阵转换成数组</span><br>&gt;&gt;&gt;a41=a3.getA()  <span class="hljs-comment">#将矩阵转换成数组</span><br>&gt;&gt;&gt;a5=a3.tolist()  <span class="hljs-comment">#将矩阵转换成列表</span><br>&gt;&gt;&gt;a6=a2.tolist()  <span class="hljs-comment">#将数组转换成列表</span><br></code></pre></td></tr></table></figure><h1 id="numpy-ndarray类型相关操作"><a href="#numpy-ndarray类型相关操作" class="headerlink" title="numpy.ndarray类型相关操作"></a>numpy.ndarray类型相关操作</h1><p>等待补充…</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://numpy.org/doc/stable/reference/index.html">numpy官方文档</a></li><li><a href="https://www.numpy.org.cn/reference/">numpy中文网</a></li><li><a href="https://blog.csdn.net/qq_38150441/article/details/79893747">numpy之python 矩阵（mat）操作</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>numpy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MATLAB相机标定</title>
    <link href="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <url>/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="一-标定目的"><a href="#一-标定目的" class="headerlink" title="一. 标定目的"></a>一. 标定目的</h1><p>将摄像头获取的图像中的某一点转换到世界坐标系中的坐标一般需要进行四个坐标系的转换：像素坐标系-&gt;图像坐标系-&gt;相机坐标系-&gt;世界坐标系。其中前两个坐标系是二维的，后两个坐标系是三维的。经过推导，最终可以得到下面这样一个转换公式。</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/1.png" class="" alt="图1"><p>推导过程可以学习这篇博客：<a href="https://ethanli.blog.csdn.net/article/details/113248118">立体视觉入门指南（1）：坐标系与相机参数</a></p><p>图1中的公式等式右边第一部分是内参矩阵，第二部分是外参矩阵。其中内参矩阵里的参数都是相机本身的参数：焦距，像素大小等。在得到一个相机但不知道其相关参数的情况下，相机标定在这时就能起作用了。</p><h1 id="二-张氏标定法"><a href="#二-张氏标定法" class="headerlink" title="二. 张氏标定法"></a>二. 张氏标定法</h1><p>张氏标定法在相机标定中被广泛使用，其中一个重要的原因是其实施方法十分简单，不需要专业的工艺制作即可完成。</p><p>可以从学习以下博客：<a href="https://blog.csdn.net/rs_lys/article/details/116332989">立体视觉入门指南（3）：相机标定之张式标定法【超详细值得收藏】</a></p><p>可以从上述博客中获取标图案，后面进行标定时使用。</p><h1 id="三-使用MATLAB工具箱标定"><a href="#三-使用MATLAB工具箱标定" class="headerlink" title="三. 使用MATLAB工具箱标定"></a>三. 使用MATLAB工具箱标定</h1><h2 id="1-安装MATLAB工具箱"><a href="#1-安装MATLAB工具箱" class="headerlink" title="1. 安装MATLAB工具箱"></a>1. 安装MATLAB工具箱</h2><p>打开MATLAB，点击附加功能-&gt;获取附加功能，搜索 Computer Vision Toolbox工具箱。</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/2.png" class=""><p>安装完成后，点击APP。</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/3.png" class=""><p>以下进行单目标定的流程，双目标定类似。</p><h2 id="2-单目标定过程"><a href="#2-单目标定过程" class="headerlink" title="2. 单目标定过程"></a>2. 单目标定过程</h2><h3 id="1-采集棋盘图"><a href="#1-采集棋盘图" class="headerlink" title="(1) 采集棋盘图"></a>(1) 采集棋盘图</h3><p>尽量让棋盘占据照片中最多的画面，这样可以得到更多有关摄像头畸变方面的信息，同时拍摄的棋盘图是具有多个角度的，拍摄照片数量要多一点，推荐12张以上。</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/4.png" class=""><h3 id="2-导入图片"><a href="#2-导入图片" class="headerlink" title="(2) 导入图片"></a>(2) 导入图片</h3><p>点击Camera Calibrator，打开标定界面：</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/5.png" class=""><p>点击Add Images，选择从文件中输入图片，把图片全部选中：</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/6.png" class=""><p>输入棋盘格的大小，然后点击确定：</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/7.png" class=""><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/8.png" class=""><p>点击确定，可以看到我这边输入的图片不太好，20张图片拒绝了11张。之后就看到了角点检测的情况了。</p><h3 id="3-标定并输出结果"><a href="#3-标定并输出结果" class="headerlink" title="(3) 标定并输出结果"></a>(3) 标定并输出结果</h3><p>点击Calibrate按钮：</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/9.png" class=""><p>点击Export Camera Parameters-&gt;Export parameters to workspace将结果输出：</p><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/10.png" class=""><img src="/2022/09/22/MATLAB%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/11.png" class=""><h1 id="三-参考"><a href="#三-参考" class="headerlink" title="三. 参考"></a>三. 参考</h1><ol><li><a href="https://blog.csdn.net/c20081052/article/details/89471176">https://blog.csdn.net/c20081052/article/details/89471176</a></li><li><a href="https://blog.csdn.net/leonardohaig/article/details/81254179">https://blog.csdn.net/leonardohaig/article/details/81254179</a></li><li><a href="https://blog.csdn.net/qq_44703886/article/details/122770420?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122770420-blog-122767064.t5_refersearch_landing&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-122770420-blog-122767064.t5_refersearch_landing&utm_relevant_index=2">【ZED】从零开始使用ZED相机（四）：双目相机标定（MATLAB+张氏标定法）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>MATLAB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS下使用摄像头发布和订阅图像（python）</title>
    <link href="/2022/09/22/ROS%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/09/22/ROS%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>ROS可以发布和订阅消息: </p><ol><li><a href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29">C++实现发布和订阅</a></li><li><a href="http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29">python实现发布和订阅</a></li></ol><p>ROS已经写好了图像发布的消息类型：<a href="http://docs.ros.org/en/noetic/api/sensor_msgs/html/index-msg.html">sensor_msgs&#x2F;Image</a></p><p>将<code>sensor_msgs/Image</code>消息类型转换成OpenCV可以使用的矩阵形式需要用到<a href="http://wiki.ros.org/cv_bridge">cv_bridge功能包</a>：</p><img src="/2022/09/22/ROS%E4%B8%8B%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E5%9B%BE%E5%83%8F/1.png" class=""><h1 id="2-创建ROS节点"><a href="#2-创建ROS节点" class="headerlink" title="2. 创建ROS节点"></a>2. 创建ROS节点</h1><h2 id="1-初始化工作空间"><a href="#1-初始化工作空间" class="headerlink" title="(1) 初始化工作空间"></a>(1) 初始化工作空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> py3_test_ws &amp;&amp; <span class="hljs-built_in">cd</span> py3_test_ws<br><span class="hljs-built_in">mkdir</span> src &amp;&amp; <span class="hljs-built_in">cd</span> src<br>catkin_init_workspace<br></code></pre></td></tr></table></figure><h2 id="2-创建功能包"><a href="#2-创建功能包" class="headerlink" title="(2) 创建功能包"></a>(2) 创建功能包</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">catkin_create_pkg</span> py3_demo rospy rosmsg roscpp<br></code></pre></td></tr></table></figure><h2 id="3-编写python3的图像发布和接收节点"><a href="#3-编写python3的图像发布和接收节点" class="headerlink" title="(3) 编写python3的图像发布和接收节点"></a>(3) 编写python3的图像发布和接收节点</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> py3_demo &amp;&amp; <span class="hljs-built_in">mkdir</span> scripts<br><span class="hljs-keyword">cd</span> scripts &amp;&amp; touch camera.<span class="hljs-keyword">py</span> img_process.<span class="hljs-keyword">py</span><br>chmod +<span class="hljs-keyword">x</span> camera.<span class="hljs-keyword">py</span><br>chmod +<span class="hljs-keyword">x</span> img_process.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>将以下代码复制到对应的文件中:</p><h2 id="摄像头发布节点-camera-py"><a href="#摄像头发布节点-camera-py" class="headerlink" title="摄像头发布节点(camera.py)"></a>摄像头发布节点(camera.py)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> std_msgs.msg <span class="hljs-keyword">import</span> Header<br><span class="hljs-keyword">from</span> sensor_msgs.msg <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> cv_bridge <span class="hljs-keyword">import</span> CvBridge , CvBridgeError<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> sys <br>    <span class="hljs-built_in">print</span>(sys.version) <span class="hljs-comment"># 查看python版本</span><br>    capture = cv2.VideoCapture(<span class="hljs-number">0</span>) <span class="hljs-comment"># 定义摄像头</span><br>    rospy.init_node(<span class="hljs-string">&#x27;camera_node&#x27;</span>, anonymous=<span class="hljs-literal">True</span>) <span class="hljs-comment">#定义节点</span><br>    image_pub=rospy.Publisher(<span class="hljs-string">&#x27;/image_view/image_raw&#x27;</span>, Image, queue_size = <span class="hljs-number">1</span>) <span class="hljs-comment">#定义话题</span><br>    <br>    header = Header(stamp = rospy.Time.now())<br>    header.frame_id = <span class="hljs-string">&quot;Camera&quot;</span><br>    ros_frame = Image()<br>    ros_frame.header=header<br>    ros_frame.width = <span class="hljs-number">640</span><br>    ros_frame.height = <span class="hljs-number">480</span><br>    ros_frame.encoding = <span class="hljs-string">&quot;bgr8&quot;</span><br>    <span class="hljs-comment"># ros_frame.step = 1920</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():    <span class="hljs-comment"># Ctrl C正常退出，如果异常退出会报错device busy！</span><br>        start = time.time()<br>        ret, frame = capture.read()<br>        <span class="hljs-keyword">if</span> ret: <span class="hljs-comment"># 如果有画面再执行</span><br>            <span class="hljs-comment"># frame = cv2.flip(frame,0)   #垂直镜像操作</span><br>            frame = cv2.flip(frame,<span class="hljs-number">1</span>)   <span class="hljs-comment">#水平镜像操作   </span><br>    <br>            ros_frame.data = np.array(frame).tostring() <span class="hljs-comment">#图片格式转换</span><br>            image_pub.publish(ros_frame) <span class="hljs-comment">#发布消息</span><br>            end = time.time()  <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cost time:&quot;</span>, end-start ) <span class="hljs-comment"># 看一下每一帧的执行时间，从而确定合适的rate</span><br>            rate = rospy.Rate(<span class="hljs-number">25</span>) <span class="hljs-comment"># 10hz </span><br><br>    capture.release()<br>    cv2.destroyAllWindows() <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;quit successfully!&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="摄像头接收处理节点-img-process-py"><a href="#摄像头接收处理节点-img-process-py" class="headerlink" title="摄像头接收处理节点(img_process.py)"></a>摄像头接收处理节点(img_process.py)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sensor_msgs.msg <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> cv_bridge <span class="hljs-keyword">import</span> CvBridge, CvBridgeError<br><span class="hljs-keyword">import</span> cv2<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">data</span>):<br>    cv_img = bridge.imgmsg_to_cv2(data, <span class="hljs-string">&quot;bgr8&quot;</span>)<br>    cv2.imshow(<span class="hljs-string">&quot;frame&quot;</span> , cv_img)<br>    cv2.waitKey(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">import</span> sys <br>    <span class="hljs-built_in">print</span>(sys.version) <span class="hljs-comment"># 查看python版本</span><br>    <br>    rospy.init_node(<span class="hljs-string">&#x27;img_process_node&#x27;</span>, anonymous=<span class="hljs-literal">True</span>)<br>    bridge = CvBridge()<br>    rospy.Subscriber(<span class="hljs-string">&#x27;/image_view/image_raw&#x27;</span>, Image, callback)<br>    rospy.spin()<br><br></code></pre></td></tr></table></figure><h1 id="3-运行节点"><a href="#3-运行节点" class="headerlink" title="3. 运行节点"></a>3. 运行节点</h1><h2 id="1-编译"><a href="#1-编译" class="headerlink" title="(1) 编译"></a>(1) 编译</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ..<span class="hljs-regexp">/../</span>..<br>catkin_make -DPYTHON_EXECUTABLE=<span class="hljs-regexp">/usr/</span>bin/python3<br></code></pre></td></tr></table></figure><h2 id="2-运行"><a href="#2-运行" class="headerlink" title="(2) 运行"></a>(2) 运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br><span class="hljs-comment"># 打开三个终端</span><br>roscore<br>rosrun py3_demo camera.py<br>rosrun py3_demo img_process.py<br></code></pre></td></tr></table></figure><p>之后就可以进行开发了。</p><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><ol><li><a href="https://blog.csdn.net/qq_45779334/article/details/119579649">https://blog.csdn.net/qq_45779334&#x2F;article&#x2F;details&#x2F;119579649</a></li><li><a href="https://blog.csdn.net/qq_45779334/article/details/124323809">C++实现</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu虚拟机如何使用摄像头</title>
    <link href="/2022/09/22/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <url>/2022/09/22/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h1><p>在虚拟机设置中将USB兼容性设置为3.x，默认是2.x：</p><img src="/2022/09/22/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/1.png" class=""><p>此时虚拟机可以检测到相关USB设备，但是一台USB设备只能链接一台主机或者虚拟机，只有断开主机的连接，虚拟机才可以连接到摄像头。<br>点击VMware菜单栏上的“虚拟机-&gt;可移动设备”：</p><img src="/2022/09/22/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/2.jpg" class=""><p>此时就可以在虚拟机中使用摄像头了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/bc93dedb697d">https://www.jianshu.com/p/bc93dedb697d</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS-Noetic安装moveit</title>
    <link href="/2022/09/21/ROS-Noetic%E5%AE%89%E8%A3%85moveit/"/>
    <url>/2022/09/21/ROS-Noetic%E5%AE%89%E8%A3%85moveit/</url>
    
    <content type="html"><![CDATA[<h1 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h1><p>在Ubuntu20.04上安装ROS-Noetic后，安装moveit。安装流程如下：</p><p>确保自己有最新的数据包：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo rosdep init<br>rosdep <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-keyword">get</span> dist-upgrade<br></code></pre></td></tr></table></figure><p>安装ROS构建工具（一般安装ROS时已经安装好了）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt install ros-noetic-catkin <span class="hljs-keyword">python3</span>-catkin-tools <span class="hljs-keyword">python3</span>-osrf-pycommon<br></code></pre></td></tr></table></figure><p>安装moveit（不用像<a href="https://ros-planning.github.io/moveit_tutorials/">官网</a>一样下载源码）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-noetic-moveit<br></code></pre></td></tr></table></figure><p>启动验证：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch moveit_setup_assistant setup_assistant.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>如果要跑官网的示例教程，首先建立一个工作空间，下载示例代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir ~<span class="hljs-regexp">/ws_moveit/</span>src<br>cd ~<span class="hljs-regexp">/ws_moveit/</span>src<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ros-planning/m</span>oveit_tutorials.git -b master<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/ros-planning/</span>panda_moveit_config.git -b melodic-devel<br></code></pre></td></tr></table></figure><p>安装依赖并编译：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/ws_moveit/src</span><br>rosdep install -y <span class="hljs-params">--from-paths</span> . <span class="hljs-params">--ignore-src</span> <span class="hljs-params">--rosdistro</span> noetic<br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br>catkin_make<br>source ~<span class="hljs-string">/ws_moveit/devel/setup.bash</span><br></code></pre></td></tr></table></figure><p>运行demo：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch panda_moveit_config demo.<span class="hljs-built_in">launch</span> rviz_tutorial:=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>ROS-Noetic版本使用的是python3，检查Ubuntu20.04的Python版本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>如果没有输出python版本，说明系统未指定python版本，执行以下指令检查系统安装的python版本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls <span class="hljs-regexp">/usr/</span>bin/python*<br></code></pre></td></tr></table></figure><p>一般有两个，一个python2，一个python3。使用以下命令可以自主选择python版本:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python python /u</span>sr<span class="hljs-regexp">/bin/</span>python2 <span class="hljs-number">1</span><br>sudo update-alternatives --install <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python python /u</span>sr<span class="hljs-regexp">/bin/</span>python3 <span class="hljs-number">2</span><br>sudo update-alternatives --config python<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
      <category>moveit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>noetic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>No such file or directory: /opt/ros/melodic/share/franka_description/robots/panda/panda.urdf.xacro [Errno 2] No such file or directory: &#39;/opt/ros/melodic/share/franka_description/robots/panda/panda.urdf.xacro&#39;...</title>
    <link href="/2022/09/17/No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro-Errno-2-No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro/"/>
    <url>/2022/09/17/No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro-Errno-2-No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>初学moveit，按照<a href="http://docs.ros.org/en/melodic/api/moveit_tutorials/html/index.html">官方教程</a>学习，根据教程一步步操作，结果才到第二节课，运行demo时：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch panda_moveit_config demo.<span class="hljs-built_in">launch</span> rviz_tutorial:=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>出现报错：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">No such <span class="hljs-keyword">file</span> or directory:<span class="hljs-regexp">/opt/</span>ros<span class="hljs-regexp">/melodic/</span>share<span class="hljs-regexp">/franka_description/</span>robots<span class="hljs-regexp">/panda/</span>panda.urdf.xacro [Errno2] No such <span class="hljs-keyword">file</span> or directory:<span class="hljs-string">&#x27;/opt/ros/melodic/share/franka_description/robots/panda/panda.urdf.xacro&#x27;</span>...<br></code></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>我本以为是我没有安装<code>franka_description</code>包，但我打开文件夹<code>/opt/ros/melodic/share/</code>，发现有这个安装包，但是没有<code>panda</code>这个文件夹。我以为时包文件丢失，重新安装了以下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-franka-description<br></code></pre></td></tr></table></figure><p>问题依旧没有解决。</p><p>去ROS官网查看<code>franka_description</code>包：<a href="http://wiki.ros.org/franka_description">http://wiki.ros.org/franka_description</a><br>打开github地址，发现github上的包文件是完整的：</p><img src="/2022/09/17/No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro-Errno-2-No-such-file-or-directory-opt-ros-melodic-share-franka-description-robots-panda-panda-urdf-xacro/1.png" class=""><p>把它克隆到moveit工作空间下的src文件夹里：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/frankaemika/</span>franka_ros<br></code></pre></td></tr></table></figure><p>安装相关依赖并编译：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">$ rosdep install</span> <span class="hljs-literal">-</span><span class="hljs-comment">y</span> <span class="hljs-literal">--</span><span class="hljs-comment">from</span><span class="hljs-literal">-</span><span class="hljs-comment">paths</span> <span class="hljs-string">.</span> <span class="hljs-literal">--</span><span class="hljs-comment">ignore</span><span class="hljs-literal">-</span><span class="hljs-comment">src</span> <span class="hljs-literal">--</span><span class="hljs-comment">rosdistro melodic</span><br><span class="hljs-comment">$ catkin_make</span><br></code></pre></td></tr></table></figure><p>重新运行：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">roslaunch panda_moveit_config demo.<span class="hljs-built_in">launch</span> rviz_tutorial:=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>成功！</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>因为工作空间中的功能吧优先级高于ROS按照的功能包，所以也不用担心重名。不过，<a href="http://wiki.ros.org/franka_description">官网</a>显示已经发布了功能包，不知道为什么使用sudo apt-get 安装的包与github上不一样。</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
      <category>moveit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>melodic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++: internal compiler error: 已杀死 (program cc1plus)</title>
    <link href="/2022/09/16/C-internal-compiler-error-%E5%B7%B2%E6%9D%80%E6%AD%BB-program-cc1plus/"/>
    <url>/2022/09/16/C-internal-compiler-error-%E5%B7%B2%E6%9D%80%E6%AD%BB-program-cc1plus/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在虚拟机中安装了ROS，并使用<code>catkin_make</code>编译项目时，出现该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ 46%] Building CXX object moveit_tutorials/doc/interactivity/CMakeFiles/interactivity_utils.dir/src/imarker.cpp.o<br>c++: internal compiler error: 已杀死 (program cc1plus)<br>Please submit a full bug report,<br>with preprocessed <span class="hljs-built_in">source</span> <span class="hljs-keyword">if</span> appropriate.<br>See &lt;file:///usr/share/doc/gcc-7/README.Bugs&gt; <span class="hljs-keyword">for</span> instructions.<br>moveit_tutorials/doc/motion_planning_api/CMakeFiles/motion_planning_api_tutorial.dir/build.make:62: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;moveit_tutorials/doc/motion_planning_api/CMakeFiles/motion_planning_api_tutorial.dir/src/motion_planning_api_tutorial.cpp.o&#x27;</span> failed<br>make[2]: *** [moveit_tutorials/doc/motion_planning_api/CMakeFiles/motion_planning_api_tutorial.dir/src/motion_planning_api_tutorial.cpp.o] Error 4<br>CMakeFiles/Makefile2:4570: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;moveit_tutorials/doc/motion_planning_api/CMakeFiles/motion_planning_api_tutorial.dir/all&#x27;</span> failed<br>make[1]: *** [moveit_tutorials/doc/motion_planning_api/CMakeFiles/motion_planning_api_tutorial.dir/all] Error 2<br>make[1]: *** 正在等待未完成的任务....<br>[ 50%] Linking CXX executable /home/cjl/ros-melodic/ws_moveit/devel/lib/moveit_tutorials/motion_planning_pipeline_tutorial<br>[ 53%] Building CXX object moveit_tutorials/doc/interactivity/CMakeFiles/interactivity_utils.dir/src/pose_string.cpp.o<br>[ 53%] Built target motion_planning_pipeline_tutorial<br>[ 57%] Linking CXX shared library /home/cjl/ros-melodic/ws_moveit/devel/lib/libinteractivity_utils.so<br>[ 60%] Linking CXX executable /home/cjl/ros-melodic/ws_moveit/devel/lib/moveit_tutorials/move_group_interface_tutorial<br>[ 60%] Built target interactivity_utils<br>[ 60%] Built target move_group_interface_tutorial<br>Makefile:140: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;all&#x27;</span> failed<br>make: *** [all] Error 2<br>Invoking <span class="hljs-string">&quot;make -j4 -l4&quot;</span> failed<br></code></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>出现这种问题的原因不是因为代码有问题，而是编译器在编译代码时，内存耗尽导致的。这里的内存指的是物理内存和虚拟内存(swap空间)。在Vmware上，这个问题比较常见，其他经常发生这种情况的平台是树莓pi和类似的SBCs(因为它们通常没有swap空间，并且物理内存也有限)。</p><p>可以使用以下代码查看物理内存和虚拟内存的大小与占用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">free -h</span><br></code></pre></td></tr></table></figure><img src="/2022/09/16/C-internal-compiler-error-%E5%B7%B2%E6%9D%80%E6%AD%BB-program-cc1plus/1.png" class="" alt="内存占用"><p>使用VMware安装Ubuntu时，因为我采用的安装方式是“清除整个磁盘并安装Ubuntu”，而非以下这种方式指定分区。可以看到系统只给我分配了不到1G的虚拟内存。</p><img src="/2022/09/16/C-internal-compiler-error-%E5%B7%B2%E6%9D%80%E6%AD%BB-program-cc1plus/2.png" class=""><blockquote><p>注意：在UBUNTU系统里面，并不是你的物理内存全部耗尽之后，系统才使用swap分区！系统的swappiness设定值，对如何使用swap分区是有着很大的联系。 如何修改两者之间的关系，参考<a href="#%E5%8F%82%E8%80%83">博客3</a></p></blockquote><p>经分析，出现该问题的原因大概率是因为虚拟空间设置过小导致的，解决方法有以下几种：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>最简单的方法是使用单线程进行编译，确定是编译速度会变慢：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">catkin_make</span> -j <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>临时增加虚拟内存空间。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo dd <span class="hljs-attribute">if</span>=/dev/zero <span class="hljs-attribute">of</span>=/swapfile <span class="hljs-attribute">bs</span>=64M <span class="hljs-attribute">count</span>=16<br><span class="hljs-comment"># count的大小就是增加的swap空间的大小，64M是块大小，所以空间大小是bs*count=1024MB</span><br><br>sudo mkswap /swapfile<br><span class="hljs-comment"># 把刚才空间格式化成swap格式</span><br><br>chmod 0600 /swapfile  <br><span class="hljs-comment"># 该目录权限，不改的话，在下一步启动时会报“swapon: /swapfile: insecure permissions 0644, 0600 suggested.”错误</span><br><br>sudo swapon /swapfile<br><span class="hljs-comment"># 使用刚才创建的swap空间</span><br></code></pre></td></tr></table></figure><p>编译完成后释放空间：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">swapoff -<span class="hljs-keyword">a</span><br><span class="hljs-comment"># 详细的用法可以：swapoff --help</span><br><br>free -h<br><span class="hljs-comment"># 查看当前内存使用情况</span><br></code></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>永久增加虚拟内存，新建并重新挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo swapoff /swapfile <br><span class="hljs-comment"># 先关闭虚拟内存</span><br><br>sudo fallocate -l 8G /swapfile<br><span class="hljs-comment"># 新建8G虚拟内存</span><br> <br><span class="hljs-built_in">ls</span> -lh /swapfile<br><span class="hljs-comment"># 查看是否已经新建swap；</span><br> <br>sudo <span class="hljs-built_in">chmod</span> 600 /swapfile<br><span class="hljs-comment"># 设置swap文件权限，只有root才能对本虚拟内存文件有读写权限；</span><br> <br><span class="hljs-built_in">ls</span> -lh /swapfile<br><span class="hljs-comment"># 查看文件信息，确认swap权限；</span><br> <br>sudo mkswap /swapfile<br><span class="hljs-comment"># 通知系统挂载swap；</span><br> <br>sudo swapon /swapfile<br><span class="hljs-comment"># 通知系统启用swap；</span><br> <br><span class="hljs-comment"># 现在虽然已经可以使用虚拟内存，但是一旦系统重启后，需要重新挂载，所以修改挂载磁盘文件达到重启后自动挂载：</span><br>sudo vi /etc/fstab<br> <br><span class="hljs-comment">#编辑脚本，打开文件后，最后面添加一行/swapfile  none  swap  sw  0  0，然后保存</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://answers.ros.org/question/348106/c-internal-compiler-error-killed-while-building-universal-robots-ros-driver/">https://answers.ros.org/question/348106/c-internal-compiler-error-killed-while-building-universal-robots-ros-driver/</a></li><li><a href="https://www.jianshu.com/p/c4ef42f6b2ec?u_atoken=accb1f50-4757-4f3f-8430-f9388c548e31&u_asession=01Sl97qhpzNtrzz3mtEYw-wA3CyQJFNHWpyqogGSfSixQfKtxtrf-HqPxHiq2wPl0LX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K9T_9PkbfI9NtGK2za4CkVMPn5sJEo90JdruCukG2OVYmBkFo3NEHBv0PZUm6pbxQU&u_asig=05xHh4IRvz0OCaBf-5Cy3OE9fe4aMvS8FPRNgfAj4GPQqgTlU-Iq8IvUS2Vh0mMEf_FKwpjFHxgICf3cFCF6AqI8jdmNS3UBrHZk4dVsm7Ys7QEQSNA1i82ReMKxPlnagFIcJRq4Mo1hmPxMVZo9d3VVc-7H3O6oW1uAMKRdrH7af9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzU0KdFsOCLwMZOAxf8iLOxIrpB0pxWIxuPEKqEpEKHhELoLNx2oKfcIBo1yjPF0Bne3h9VXwMyh6PgyDIVSG1W9JpQAZ1eYztvV05qTc_LG75wXlYElZ4cq7YXSAdlfppbSqcceQuk9g-QpfEp97nmQwRREAJVszkQw8SBfELMt5mWspDxyAEEo4kbsryBKb9Q&u_aref=dt6SQ8S9vuUu7VT3LkIHdhamzvs=">解决c++: internal compiler error: 已杀死 (program cc1plus)</a></li><li><a href="https://blog.csdn.net/Steve_Rogan/article/details/121574843">https://blog.csdn.net/Steve_Rogan&#x2F;article&#x2F;details&#x2F;121574843</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>melodic</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS初学笔记</title>
    <link href="/2022/09/12/ROS%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/12/ROS%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><ol><li><a href="http://wiki.ros.org/">http://wiki.ros.org/</a></li><li><a href="https://www.guyuehome.com/">https://www.guyuehome.com/</a></li></ol><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>查看ROS环境设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">printenv</span> | grep ROS</span><br></code></pre></td></tr></table></figure><p>创建工作空间并编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">catkin_make</span><br></code></pre></td></tr></table></figure><p>使用工作空间中的功能包或节点需要先设置环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> devel/setup.bash</span><br></code></pre></td></tr></table></figure><p>检查是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span></span><br></code></pre></td></tr></table></figure><h2 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h2><p>查询ros可安装功能包：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>apt-cache search ros-melodic<br></code></pre></td></tr></table></figure><p>安装某个功能包(不知道确切名字，按tab键有惊喜)：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> install ros-melodic-ros-tutorials<br></code></pre></td></tr></table></figure><p>查询已安装功能包:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rospack list<br></code></pre></td></tr></table></figure><p>查看某个安装包(roscpp)的安装位置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rospack <span class="hljs-built_in">find</span> roscpp<br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>$ rospack help</code> 了解更多rospack命令</p></blockquote><p>更改终端路径到某一个包的位置:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>roscd roscpp<br></code></pre></td></tr></table></figure><blockquote><p>roscd和其他的ROS工具一样，只能找ROS_PACKAGE_PATH中的功能包，查看命令 <code>$ echo $ROS_PACKAGE_PATH</code></p></blockquote><p>查看功能包目录：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosls roscpp<br></code></pre></td></tr></table></figure><h2 id="创建ROS功能包"><a href="#创建ROS功能包" class="headerlink" title="创建ROS功能包"></a>创建ROS功能包</h2><p>在工作空间中的功能包结构可能如下所示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">workspace_folder/        <span class="hljs-comment">-- WORKSPACE</span><br>  src/                   <span class="hljs-comment">-- SOURCE SPACE</span><br>    CMakeLists.txt       <span class="hljs-comment">-- &#x27;Toplevel&#x27; CMake file, provided by catkin</span><br>    package_1/<br>      CMakeLists.txt     <span class="hljs-comment">-- CMakeLists.txt file for package_1</span><br>      <span class="hljs-keyword">package</span>.xml        <span class="hljs-comment">-- Package manifest for package_1</span><br>    ...<br>    package_n/<br>      CMakeLists.txt     <span class="hljs-comment">-- CMakeLists.txt file for package_n</span><br>      <span class="hljs-keyword">package</span>.xml        <span class="hljs-comment">-- Package manifest for package_n</span><br></code></pre></td></tr></table></figure><p>在..&#x2F;catkin_ws&#x2F;src目录下，使用以下命令创建新的功能包：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># This <span class="hljs-keyword">is</span> an example, <span class="hljs-keyword">do</span> not <span class="hljs-keyword">try</span> to run <span class="hljs-keyword">this</span><br># catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]<br>$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp<br></code></pre></td></tr></table></figure><p>然后在..&#x2F;catkin_ws目录下，使用 <code>$ catkin_make</code>进行编译。<br>不要忘记添加工作区到ROS环境:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ . ~<span class="hljs-regexp">/catkin_ws/</span>devel/setup.bash<br></code></pre></td></tr></table></figure><p>查看某个功能包的一级依赖：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rospack depends1 beginner_tutorials <br></code></pre></td></tr></table></figure><p>查看所有依赖：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rospack depends beginner_tutorials<br></code></pre></td></tr></table></figure><h2 id="理解ROS节点"><a href="#理解ROS节点" class="headerlink" title="理解ROS节点"></a>理解ROS节点</h2><p>使用ROS时先运行:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>roscore<br></code></pre></td></tr></table></figure><p>查看当前在运行的ROS节点：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosnode list<br></code></pre></td></tr></table></figure><blockquote><p>有时可能已经终止的节点没有及时清除，可以手动清除：<code>$ rosnode cleanup</code></p></blockquote><p>查看某个节点的信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rosnode <span class="hljs-built_in">info</span> /rosout<br></code></pre></td></tr></table></figure><p>运行某个功能包中的节点：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># rosrun [package_name] [node_name]</span><br><span class="hljs-variable">$ </span>rosrun turtlesim turtlesim_node<br></code></pre></td></tr></table></figure><p>可以使用重映射给节点换名：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun turtlesim turtlesim_node <span class="hljs-symbol">__name:</span>=my_turtle<br></code></pre></td></tr></table></figure><p>可以使用ping测试节点是否启动:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$ rosnode <span class="hljs-built_in">ping</span> my_turtle<br></code></pre></td></tr></table></figure><h2 id="理解ROS话题"><a href="#理解ROS话题" class="headerlink" title="理解ROS话题"></a>理解ROS话题</h2><p>使用ROS时先运行:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>roscore<br></code></pre></td></tr></table></figure><p>然后打开两个终端，分别运行：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun turtlesim turtlesim_node<br><span class="hljs-variable">$ </span>rosrun turtlesim turtle_teleop_key<br></code></pre></td></tr></table></figure><p>打开新的终端，运行以下命令可以看到订阅关系：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun rqt_graph rqt_graph<br></code></pre></td></tr></table></figure><p>未安装则运行以下命令进行安装:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo apt-<span class="hljs-built_in">get</span> install ros-&lt;distro&gt;-rqt<br>$ sudo apt-<span class="hljs-built_in">get</span> install ros-&lt;distro&gt;-rqt-common-plugins<br></code></pre></td></tr></table></figure><p>rostopic工具允许你得到ROS话题的相关信息，使用以下命令得到相关用法：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rostopic -h<br></code></pre></td></tr></table></figure><p>使用echo打印发布或接收的话题信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rostopic <span class="hljs-built_in">echo</span> /turtle1/cmd_vel</span><br></code></pre></td></tr></table></figure><p>使用<code>rostopic list</code>列举当前正在运行的话题：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rostopic list -h     <span class="hljs-comment"># 展示帮助信息</span><br><span class="hljs-variable">$ </span>rostopic list -v     <span class="hljs-comment"># 列举所有话题</span><br><span class="hljs-variable">$ </span>rostopic list -p     <span class="hljs-comment"># 只列举publisher    </span><br><span class="hljs-variable">$ </span>rostopic list -s     <span class="hljs-comment"># 只列举subscriber</span><br></code></pre></td></tr></table></figure><p>查看话题使用的消息类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rostopic <span class="hljs-built_in">type</span> /turtle1/cmd_vel</span><br></code></pre></td></tr></table></figure><p>使用rosmsg查看消息类型细节：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosmsg show geometry_msgs/Twist<br></code></pre></td></tr></table></figure><p>使用<code>rostopic pub</code>发布数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rostopic pub [topic] [msg_type] [args]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, 1.8]&#x27;</span></span><br></code></pre></td></tr></table></figure><p>其中 -1 表示只发布一次，-r 表示循环发布，后面接参数表示频率（以hz为单位）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, -1.8]&#x27;</span></span><br></code></pre></td></tr></table></figure><p>查看话题发布频率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rostopic hz [topic]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rostopic hz /turtle1/pose</span><br></code></pre></td></tr></table></figure><h2 id="理解ROS服务和参数"><a href="#理解ROS服务和参数" class="headerlink" title="理解ROS服务和参数"></a>理解ROS服务和参数</h2><p>查看当前服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosservice list<br></code></pre></td></tr></table></figure><p>查看某个服务类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rosservice <span class="hljs-built_in">type</span> [service]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rosservice <span class="hljs-built_in">type</span> /clear</span><br></code></pre></td></tr></table></figure><p>调用服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rosservice call [service] [args]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rosservice call /clear</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rosservice call /spawn 2 2 0.2 <span class="hljs-string">&quot;&quot;</span></span><br></code></pre></td></tr></table></figure><p>查看当前参数服务器上的参数：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosparam list<br></code></pre></td></tr></table></figure><p>设置参数值以及获取参数值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rosparam <span class="hljs-built_in">set</span> [param_name]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rosparam get [param_name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rosparam <span class="hljs-built_in">set</span> /turtlesim/background_r 150</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rosparam get /turtlesim/background_g</span> <br></code></pre></td></tr></table></figure><p>使用以下命令展示所有参数值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ rosparam <span class="hljs-built_in">get</span> /<br></code></pre></td></tr></table></figure><p>使用文件加载或者存储参数：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># rosparam dump [file_name] [namespace]</span><br><span class="hljs-comment"># rosparam load [file_name] [namespace]</span><br>$ rosparam dump <span class="hljs-built_in">params</span>.yaml<br>$ rosparam <span class="hljs-built_in">load</span> <span class="hljs-built_in">params</span>.yaml copy_turtle<br></code></pre></td></tr></table></figure><h2 id="使用rqt-console和roslaunch"><a href="#使用rqt-console和roslaunch" class="headerlink" title="使用rqt_console和roslaunch"></a>使用rqt_console和roslaunch</h2><p>rqt_console连接到ROS的日志记录框架，以显示来自节点的输出。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun rqt_console rqt_console<br></code></pre></td></tr></table></figure><p>rqt_logger_level允许我们在节点运行时更改节点的详细级别(DEBUG、WARN、INFO和ERROR)。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rosrun rqt_logger_level rqt_logger_level<br></code></pre></td></tr></table></figure><p>Roslaunch可以启动launch文件中定义的节点。它的用法如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ roslaunch <span class="hljs-comment">[package]</span> <span class="hljs-comment">[filename.launch]</span><br></code></pre></td></tr></table></figure><p>例如，在beginner_tutotrals中新建一个launch文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/catkin_ws</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> devel/setup.bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">roscd beginner_tutorials</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> launch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> launch</span><br></code></pre></td></tr></table></figure><blockquote><p>NOTE: The directory to store launch files doesn’t necessarily have to be named launch. In fact you don’t even need to store them in a directory. roslaunch command automatically looks into the passed package and detects available launch files. However, this is considered good practice.</p></blockquote><p>turtlemimic.launch文件内容如下，作用是启动两个小海龟，其中一个跟着另一个移动：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;launch&gt;<br><br>  &lt;group ns<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim1&quot;</span>&gt;<br>    &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sim&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;<br>  &lt;/group&gt;<br><br>  &lt;group ns<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim2&quot;</span>&gt;<br>    &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sim&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;<br>  &lt;/group&gt;<br><br>  &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;mimic&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;mimic&quot;</span>&gt;<br>    &lt;remap from<span class="hljs-operator">=</span><span class="hljs-string">&quot;input&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim1/turtle1&quot;</span>/&gt;<br>    &lt;remap from<span class="hljs-operator">=</span><span class="hljs-string">&quot;output&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim2/turtle1&quot;</span>/&gt;<br>  &lt;/node&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>使用以下命令启动：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ roslaunch beginner_tutorials turtlemimic.<span class="hljs-built_in">launch</span><br></code></pre></td></tr></table></figure><p>然后发布话题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ rostopic pub <span class="hljs-regexp">/turtlesim1/</span>turtle1<span class="hljs-regexp">/cmd_vel geometry_msgs/</span>Twist -r <span class="hljs-number">1</span> -- <span class="hljs-string">&#x27;[2.0, 0.0, 0.0]&#x27;</span> <span class="hljs-string">&#x27;[0.0, 0.0, -1.8]&#x27;</span><br></code></pre></td></tr></table></figure><p>使用以下命令更好的理解节点间的关系：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rqt_graph<br></code></pre></td></tr></table></figure><h2 id="使用rosmsg和rossrv"><a href="#使用rosmsg和rossrv" class="headerlink" title="使用rosmsg和rossrv"></a>使用rosmsg和rossrv</h2><p>rosmsg功能包包含两个命令行工具：rosmsg和rossrv。其中rosmsg用于显示ROS消息类型信息，rossrv用于显示ROS服务类型信息。</p><p>rossrv与rosmsg用法一致，这里只介绍rosmsg的用法。</p><p>列举所有消息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosmsg list</span><br></code></pre></td></tr></table></figure><p>列举所有定义消息的功能包：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosmsg packages</span><br></code></pre></td></tr></table></figure><p>列举某个功能包包含的消息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">rosmsg <span class="hljs-keyword">package</span> <span class="hljs-title">nav_msgs</span><br></code></pre></td></tr></table></figure><p>展示相关消息的定义信息：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">rosmsg <span class="hljs-keyword">show</span> std_msgs/<span class="hljs-keyword">String</span><br><br><span class="hljs-meta">#展示消息的原始信息</span><br>rosmsg <span class="hljs-keyword">show</span> -r robot_msgs/Quaternion<br></code></pre></td></tr></table></figure><p>获取更多信息使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rosmsg -h</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>melodic</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sudo rosdep init|rosdep update相关问题的解决方法</title>
    <link href="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>以下资源来自ROS2官网：<a href="https://docs.ros.org/en/humble/Tutorials/Intermediate/Rosdep.html">https://docs.ros.org/en/humble/Tutorials/Intermediate/Rosdep.html</a></p></blockquote><p><em>rosdep</em>是ROS的依赖管理实用工具，可以与ROS包和外部库一起工作。<em>rosdep</em>是一个命令行工具，用于自动识别和安装（安装包的）依赖项。它可以在以下情况被调用:</p><ul><li>构建工作区，并需要适当的依赖关系来构建其中的包时</li><li>安装了某个包(例如sudo apt install ros-humble-demo-nodes-cpp)，需要检查它执行所需的依赖关系时</li><li>其他</li></ul><p>使用<em>rosdep</em>工具之前，必须使用以下命令初始化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sudo rosdep <span class="hljs-keyword">init</span><br>rosdep update<br></code></pre></td></tr></table></figure><p>之后便可以使用<em>rosdep install</em>安装依赖项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">rosdep install <span class="hljs-attr">--from-paths</span> <span class="hljs-attribute">src</span> -y <span class="hljs-attr">--ignore-src</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><em>–from-paths src</em> 指定要检查要解析密钥的package.xml文件的路径</li><li><em>-y</em> 表示对包管理器的所有提示默认为 <em>yes</em>，安装时不提示</li><li><em>–ignore-src</em> 意味着忽略安装依赖项，即使rosdep键存在，如果包本身也在工作空间中。</li></ul><p>对于其他参数，可使用 <code>rosdep -h</code> 命令查看。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在构建工作区之前，需要解析包依赖关系。虽然可能已经有了所有的依赖项，但最佳实践是在每次克隆相关包时检查依赖项。谁也不希望由于缺少依赖项而导致长时间等待后构建失败。这时就需要用到 <em>rosdep</em> 命令。</p><p>首先是<code>sudo rosdep init</code>命令，出现以下错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cjl@cjl-Ubuntu22:~/ros2/ros2_ws$ sudo rosdep init<br><br>ERROR: Rosdep experienced an error: The <span class="hljs-keyword">read</span> operation timed <span class="hljs-keyword">out</span><br>Please go <span class="hljs-keyword">to</span> the rosdep page [<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> file a bug report <span class="hljs-keyword">with</span> the stack trace below.<br>[<span class="hljs-number">1</span>] : http://www.ros.org/wiki/rosdep<br><br>rosdep <span class="hljs-keyword">version</span>: <span class="hljs-number">0.22</span><span class="hljs-number">.1</span><br><br>Traceback (most recent <span class="hljs-keyword">call</span> last):<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/main.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">146</span>, <span class="hljs-keyword">in</span> rosdep_main<br>    exit_code = _rosdep_main(args)<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/main.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">444</span>, <span class="hljs-keyword">in</span> _rosdep_main<br>    <span class="hljs-keyword">return</span> _no_args_handler(command, <span class="hljs-keyword">parser</span>, <span class="hljs-keyword">options</span>, args)<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/main.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">453</span>, <span class="hljs-keyword">in</span> _no_args_handler<br>    <span class="hljs-keyword">return</span> command_handlers[command](<span class="hljs-keyword">options</span>)<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/main.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">597</span>, <span class="hljs-keyword">in</span> command_init<br>    data = download_default_sources_list()<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/sources_list.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">326</span>, <span class="hljs-keyword">in</span> download_default_sources_list<br>    f = urlopen_gzip(url, timeout=DOWNLOAD_TIMEOUT)<br>  File &quot;/usr/lib/python3/dist-packages/rosdep2/url_utils.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">50</span>, <span class="hljs-keyword">in</span> urlopen_gzip<br>    response = urlopen(url_request, **kwargs)<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">216</span>, <span class="hljs-keyword">in</span> urlopen<br>    <span class="hljs-keyword">return</span> opener.<span class="hljs-keyword">open</span>(url, data, timeout)<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">519</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">open</span><br>    response = self._open(req, data)<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">536</span>, <span class="hljs-keyword">in</span> _open<br>    result = self._call_chain(self.handle_open, protocol, protocol +<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">496</span>, <span class="hljs-keyword">in</span> _call_chain<br>    result = func(*args)<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1391</span>, <span class="hljs-keyword">in</span> https_open<br>    <span class="hljs-keyword">return</span> self.do_open(http.client.HTTPSConnection, req,<br>  File &quot;/usr/lib/python3.10/urllib/request.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1352</span>, <span class="hljs-keyword">in</span> do_open<br>    r = h.getresponse()<br>  File &quot;/usr/lib/python3.10/http/client.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1374</span>, <span class="hljs-keyword">in</span> getresponse<br>    response.<span class="hljs-keyword">begin</span>()<br>  File &quot;/usr/lib/python3.10/http/client.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">318</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">version</span>, status, reason = self._read_status()<br>  File &quot;/usr/lib/python3.10/http/client.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">279</span>, <span class="hljs-keyword">in</span> _read_status<br>    <span class="hljs-type">line</span> = str(self.fp.readline(_MAXLINE + <span class="hljs-number">1</span>), &quot;iso-8859-1&quot;)<br>  File &quot;/usr/lib/python3.10/socket.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">705</span>, <span class="hljs-keyword">in</span> readinto<br>    <span class="hljs-keyword">return</span> self._sock.recv_into(b)<br>  File &quot;/usr/lib/python3.10/ssl.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1273</span>, <span class="hljs-keyword">in</span> recv_into<br>    <span class="hljs-keyword">return</span> self.<span class="hljs-keyword">read</span>(nbytes, buffer)<br>  File &quot;/usr/lib/python3.10/ssl.py&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1129</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">read</span><br>    <span class="hljs-keyword">return</span> self._sslobj.<span class="hljs-keyword">read</span>(len, buffer)<br>TimeoutError: The <span class="hljs-keyword">read</span> operation timed <span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p><strong>此问题可以通过开启代理解决。</strong></p><p>然后是<code>rosdep update</code>命令，出现以下问题：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">cjl@cjl-Ubuntu22:~/ros2/ros2_ws$ rosdep update<br>reading in sources list data from /etc/ros/rosdep/sources.list.d<br><span class="hljs-keyword">ERROR: </span>error loading sources list:<br>        The read operation timed out<br></code></pre></td></tr></table></figure><p>有时可能会Hit几个，但总会报错，不能运行成功，即使开启代理也是如此。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>出现这个问题的原因不必多说。解决方法如下（主要是<code>rosdep update</code>问题）：</p><ol><li><p>查看报错，发现资源列表数据读取来自文件夹<code>/etc/ros/rosdep/sources.list.d</code>，该文件夹下有一个名为<code>20-default.list</code>的文件，打开如下：</p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.png" class=""></li><li><p>网站<code>https://ghproxy.com/</code>支持github的资源代理，非常好用，我们将用此代理加速rosdep对Github Raw的访问，进而解决rosdep update超时问题。具体操作是在每个url前面加上<code>https://ghproxy.com/</code>，如下：</p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/2.png" class=""><blockquote><p>注意：可使用<code>sudo gedit /etc/ros/rosdep/sources.list.d/20-default.list</code>获取更改权限</p></blockquote></li><li><p>重新尝试，并未成功</p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/3.png" class=""><p>报错的链接并未加上代理，而且这个链接20-default.list文件中并没有。这说明另有文件。</p></li><li><p>经查询，包含资源下载函数的文件如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo gedit <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist-packages<span class="hljs-regexp">/rosdep2/</span>sources_list.py<br></code></pre></td></tr></table></figure></li><li><p>在下面位置加上命令<code>url=&quot;https://ghproxy.com/&quot;+url</code></p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/4.png" class=""><blockquote><p>注意：将20-default.list文件改回原样，不然就是加了两次前缀。</p></blockquote></li><li><p>使用同样的方法修改<code>/usr/lib/python3/dist-packages/rosdistro/__init__.py</code>文件。</p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/5.png" class=""></li><li><p>同样包含 <a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com/</a>… 地址的文件还有如下几个文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist-packages<span class="hljs-regexp">/rosdep2/g</span>bpdistro_support.py <span class="hljs-number">34</span>行<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist-packages<span class="hljs-regexp">/rosdep2/</span>sources_list.py <span class="hljs-number">64</span>行<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist-packages<span class="hljs-regexp">/rosdep2/</span>rep3.py<span class="hljs-number">36</span>行<br><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/python3/</span>dist-packages<span class="hljs-regexp">/rosdistro/m</span>anifest_provider/github.py <span class="hljs-number">68</span>行 <span class="hljs-number">119</span>行<br></code></pre></td></tr></table></figure></li><li><p>&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;rosdep2&#x2F;gbpdistro_support.py文件：</p><img src="/2022/09/07/sudo-rosdep-init-rosdep-update%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/6.png" class=""></li><li><p>运行<code>rosdep update</code>命令，成功执行：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs subunit">cjl@cjl-Ubuntu22:~/ros2/ros2_ws$ rosdep update<br>reading in sources list data from /etc/ros/rosdep/sources.list.d<br>Hit https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml<br>Hit https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml<br>Hit https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/python.yaml<br>Hit https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/ruby.yaml<br>Hit https://raw.githubusercontent.com/ros/rosdistro/master/releases/fuerte.yaml<br>Query rosdistro index https://ghproxy.com/https://raw.githubusercontent.com/ros/rosdistro/master/index-v4.yaml<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;ardent&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;bouncy&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;crystal&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;dashing&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;eloquent&quot;<br>Add distro &quot;foxy&quot;<br>Add distro &quot;galactic&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;groovy&quot;<br>Add distro &quot;humble&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;hydro&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;indigo&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;jade&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;kinetic&quot;<br><span class="hljs-keyword">Skip </span>end-of-life distro &quot;lunar&quot;<br>Add distro &quot;melodic&quot;<br>Add distro &quot;noetic&quot;<br>Add distro &quot;rolling&quot;<br>updated cache in /home/cjl/.ros/rosdep/sources.cache<br></code></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/392082731">https://zhuanlan.zhihu.com/p/392082731</a></li><li><a href="https://blog.csdn.net/leida_wt/article/details/115120940?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">https://blog.csdn.net/leida_wt&#x2F;article&#x2F;details&#x2F;115120940?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm&#x3D;1001.2101.3001.4242</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ROS2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>humble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一键安装ROS2 humble</title>
    <link href="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/"/>
    <url>/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>系统配置为：虚拟机Ubuntu 22.04。ROS2 humble官方文档有两种安装方式：</p><ol><li>binary安装：<a href="https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Install-Binary.html">https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Install-Binary.html</a></li><li>source安装：<a href="https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Development-Setup.html">https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Development-Setup.html</a></li></ol><p>本文尝试使用一种简单的安装方式，来自<a href="http://fishros.com/#/fish_home">鱼香ROS</a>的一键安装脚本。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>一键安装指令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>fishros.com/install -O fishros &amp;&amp; . fishros<br></code></pre></td></tr></table></figure><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/1.png" class=""><p>根据自己的需求键入数字，这里安装ROS2，键入1回车：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/2.png" class=""><p>键入1回车：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/3.png" class=""><p>键入2回车：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/4.png" class=""><p>键入1回车：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/5.png" class=""><p>桌面版包含ROS，RViz，示例，教程等，比较全面。而基础版没有GUI工具。这里安装桌面版，键入1回车，等待一会：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/6.png" class="" alt="等待安装"><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/7.png" class="" alt="安装完成"><p>打开.bashrc文件，拉到最下面可以看到：</p><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/8.png" class=""><p>可以看到环境已经设置好了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用ROS2测试一些样例，打开一个终端运行C++ <em>talker</em>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ros2 <span class="hljs-built_in">run</span> demo_nodes_cpp talker<br></code></pre></td></tr></table></figure><p>打开另一个终端运行Python <em>listener</em>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ros2 <span class="hljs-built_in">run</span> demo_nodes_py listener<br></code></pre></td></tr></table></figure><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/9.png" class="" alt="talker"><img src="/2022/09/04/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85ROS2-humble/10.png" class="" alt="listener"><p><strong>安装成功！</strong></p>]]></content>
    
    
    <categories>
      
      <category>ROS2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>humble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware安装Ubuntu22.04</title>
    <link href="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/"/>
    <url>/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/</url>
    
    <content type="html"><![CDATA[<h1 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h1><p>这里安装的是VMware Workstation Pro 16虚拟机，安装教程（带密钥）如下：<br><a href="https://blog.csdn.net/qq_40950957/article/details/80467513">https://blog.csdn.net/qq_40950957&#x2F;article&#x2F;details&#x2F;80467513</a></p><h1 id="安装Ubuntu虚拟环境"><a href="#安装Ubuntu虚拟环境" class="headerlink" title="安装Ubuntu虚拟环境"></a>安装Ubuntu虚拟环境</h1><h2 id="1-下载Ubuntu22-04"><a href="#1-下载Ubuntu22-04" class="headerlink" title="1. 下载Ubuntu22.04"></a>1. 下载Ubuntu22.04</h2><p>Ubuntu官网：<a href="https://cn.ubuntu.com/download/desktop">https://cn.ubuntu.com/download/desktop</a></p><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/1.png" class=""><h2 id="2-VMware操作"><a href="#2-VMware操作" class="headerlink" title="2. VMware操作"></a>2. VMware操作</h2><p>打开VMware，创建新的虚拟机，按照图片一步步操作。</p><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/2.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/3.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/4.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/5.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/6.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/7.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/8.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/9.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/10.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/11.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/12.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/13.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/14.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/15.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/16.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/17.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/18.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/19.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/20.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/21.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/22.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/23.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/24.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/25.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/26.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/27.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/28.png" class=""><img src="/2022/09/02/VMware%E5%AE%89%E8%A3%85Ubuntu22-04/29.png" class=""><h2 id="3-相关问题"><a href="#3-相关问题" class="headerlink" title="3. 相关问题"></a>3. 相关问题</h2><p>安装完成后，发现无法自动放大缩小屏幕，并且也无法进行主机与虚拟机之间的复制粘贴操作，参照以下博客解决：</p><ol><li><a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/16.0/com.vmware.ws.using.doc/GUID-08BB9465-D40A-4E16-9E15-8C016CC8166F.html">https://docs.vmware.com/cn/VMware-Workstation-Pro/16.0/com.vmware.ws.using.doc/GUID-08BB9465-D40A-4E16-9E15-8C016CC8166F.html</a></li><li><a href="https://blog.csdn.net/qq_43656475/article/details/126111925">https://blog.csdn.net/qq_43656475&#x2F;article&#x2F;details&#x2F;126111925</a></li></ol><h2 id="4-相关资源"><a href="#4-相关资源" class="headerlink" title="4. 相关资源"></a>4. 相关资源</h2><ol><li><a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/16.0/com.vmware.ws.using.doc/GUID-0EE752F8-C159-487A-9159-FE1F646EE4CA.html">VMware16官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/270908077">Ubuntu安装软件有这5种方法</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo博客使用markdown引入图片无法显示的问题</title>
    <link href="/2022/08/31/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8markdown%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/31/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8markdown%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>本人使用的是Fluid主题，将_config.yaml文件中的post_asset_folder选项设为true后，每次使用</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [<span class="hljs-built_in">title</span>]<br></code></pre></td></tr></table></figure><p>创建新文章时都会自动创建一个同名文件夹，用于存放文章相关的资源，例如图片等。这时我们可以通过相对路径来引用它们。</p><p>但是常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。官方推荐的做法时使用下面的标签插件而不是markdown：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#123;<span class="hljs-symbol">%</span> asset_img <span class="hljs-built_in">example</span>.jpg This <span class="hljs-built_in">is</span> an <span class="hljs-built_in">example</span> <span class="hljs-built_in">image</span> <span class="hljs-symbol">%</span>&#125;<br></code></pre></td></tr></table></figure><p>但这种方式，在本地开发中并不友好。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>使用hexo的插件来解决，我发现了一个名为<a href="https://github.com/ZaiZheTingDun/hexo-simple-image">hexo-simple-image</a>的插件能完美解决我的问题。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install hexo-simple-<span class="hljs-built_in">image</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这个问题产生的原因，本质上是因为md文件转html文件时，图片路径某些元素的丢失，比如日期。在public文件夹下，可以看到对应的转换。hexo官网的插件<a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a>有一些解决办法，我也是尝试了hexo-asset-image等几个插件后，才找到合适的。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><!-- <img src="/2022/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="蒙娜丽莎"> --><!-- 56 --><img src="/2022/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" alt="图片引用方法三"><p><a href="https://github.com/chenjiadragon/chenjiadragon.github.io/blob/main/2022/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/1.pdf">论文</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/26/hello-world/"/>
    <url>/2022/08/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
